File: /empty 
shlomi

File: /Dockerfile 
FROM node:18.18.0-alpine

RUN apk add g++ make py3-pip

WORKDIR /usr/src/app

COPY package.json ./

COPY .npmrc .npmrc

COPY yarn.lock ./

RUN yarn install

COPY . .

RUN yarn build

EXPOSE 2400

CMD [ "yarn", "serve" ]

File: /jest.config.js 
// For a detailed explanation regarding each configuration property, visit:
// https://jestjs.io/docs/en/configuration.html

module.exports = {
    // All imported modules in your tests should be mocked automatically
    // automock: false,

    // Stop running tests after `n` failures
    // bail: 0,

    // The directory where Jest should store its cached dependency information
    // cacheDirectory: "/private/var/folders/6s/x_61zbd10s99cx774w62gm380000gn/T/jest_dx",

    // Automatically clear mock calls and instances between every test
    clearMocks: true,

    // Indicates whether the coverage information should be collected while executing the test
    // collectCoverage: false,

    // An array of glob patterns indicating a set of files for which coverage information should be collected
    // collectCoverageFrom: undefined,
    "collectCoverageFrom": [
        "src/**/*.ts"
    ],

    // The directory where Jest should output its coverage files
    coverageDirectory: "/tmp/coverage",

    // An array of regexp pattern strings used to skip coverage collection
    // coveragePathIgnorePatterns: [
    //   "/node_modules/"
    // ],

    // Indicates which provider should be used to instrument code for coverage
    coverageProvider: "v8",

    // A list of reporter names that Jest uses when writing coverage reports
    // coverageReporters: [
    //   "json",
    //   "text",
    //   "lcov",
    //   "clover"
    // ],

    // An object that configures minimum threshold enforcement for coverage results
    // coverageThreshold: undefined,

    // A path to a custom dependency extractor
    // dependencyExtractor: undefined,

    // Make calling deprecated APIs throw helpful error messages
    // errorOnDeprecated: false,

    // Force coverage collection from ignored files using an array of glob patterns
    // forceCoverageMatch: [],

    // A path to a module which exports an async function that is triggered once before all test suites
    //   globalSetup: "<rootDir>/test/test-utils/globalSetup.ts",

    // A path to a module which exports an async function that is triggered once after all test suites
    // globalTeardown: undefined,

    // A set of global variables that need to be available in all test environments
    // globals: {},

    // The maximum amount of workers used to run your tests. Can be specified as % or a number. E.g. maxWorkers: 10% will use 10% of your CPU amount + 1 as the maximum worker number. maxWorkers: 2 will use a maximum of 2 workers.
    // maxWorkers: "50%",

    // An array of directory names to be searched recursively up from the requiring module's location
    // moduleDirectories: [
    //   "node_modules"
    // ],

    // An array of file extensions your modules use
    // moduleFileExtensions: [
    //   "js",
    //   "json",
    //   "jsx",
    //   "ts",
    //   "tsx",
    //   "node"
    // ],

    // A map from regular expressions to module names or to arrays of module names that allow to stub out resources with a single module
    // moduleNameMapper: {},

    // An array of regexp pattern strings, matched against all module paths before considered 'visible' to the module loader
    // modulePathIgnorePatterns: [],

    // Activates notifications for test results
    // notify: false,

    // An enum that specifies notification mode. Requires { notify: true }
    // notifyMode: "failure-change",

    // A preset that is used as a base for Jest's configuration
    preset: 'ts-jest',

    // Run tests from one or more projects
    // projects: undefined,

    // Use this configuration option to add custom reporters to Jest
    "reporters": [
        "default",
        ["./node_modules/jest-html-reporter", {
            "pageTitle": "Test Report",
            "includeFailureMsg": true,
            "outputPath": "/tmp/html/index.html"
        }]
    ],

    // Automatically reset mock state between every test
    // resetMocks: false,

    // Reset the module registry before running each individual test
    // resetModules: false,

    // A path to a custom resolver
    // resolver: undefined,

    // Automatically restore mock state between every test
    // restoreMocks: false,

    // The root directory that Jest should scan for tests and modules within
    // rootDir: undefined,

    // A list of paths to directories that Jest should use to search for files in
    roots: [
        "<rootDir>/test"
    ],

    // Allows you to use a custom runner instead of Jest's default test runner
    // runner: "jest-runner",

    // The paths to modules that run some code to configure or set up the testing environment before each test
    // setupFiles: ["<rootDir>/test/test-utils/globalSetup.ts"],
    // A list of paths to modules that run some code to configure or set up the testing framework before each test
    setupFilesAfterEnv: ["<rootDir>/test/test-utils/setup.ts"],

    // The number of seconds after which a test is considered as slow and reported as such in the results.
    // slowTestThreshold: 5,

    // A list of paths to snapshot serializer modules Jest should use for snapshot testing
    // snapshotSerializers: [],

    // The test environment that will be used for testing
    testEnvironment: "node",

    // Options that will be passed to the testEnvironment
    // testEnvironmentOptions: {},

    // Adds a location field to test results
    // testLocationInResults: false,

    // The glob patterns Jest uses to detect test files
    // testMatch: [
    //   "**/__tests__/**/*.[jt]s?(x)",
    //   "**/?(*.)+(spec|test).[tj]s?(x)"
    // ],

    // An array of regexp pattern strings that are matched against all test paths, matched tests are skipped
    // testPathIgnorePatterns: [
    //   "/node_modules/"
    // ],

    // The regexp pattern or array of patterns that Jest uses to detect test files
    // testRegex: [],

    // This option allows the use of a custom results processor
    // testResultsProcessor: undefined,

    // This option allows use of a custom test runner
    // testRunner: "jasmine2",

    // This option sets the URL for the jsdom environment. It is reflected in properties such as location.href
    // testURL: "http://localhost",

    // Setting this value to "fake" allows the use of fake timers for functions such as "setTimeout"
    // timers: "real", 
    testTimeout: 99999, 
    // A map from regular expressions to paths to transformers
    transform: {
        "^.+\\.(ts|tsx)$": "ts-jest"
    },

    // An array of regexp pattern strings that are matched against all source file paths, matched files will skip transformation
    // transformIgnorePatterns: [
    //   "/node_modules/",
    //   "\\.pnp\\.[^\\/]+$"
    // ],

    // An array of regexp pattern strings that are matched against all modules before the module loader will automatically return a mock for them
    // unmockedModulePathPatterns: undefined,

    // Indicates whether each individual test should be reported during the run
    // verbose: undefined,

    // An array of regexp patterns that are matched against all source file paths before re-running tests in watch mode
    // watchPathIgnorePatterns: [],

    // Whether to use watchman for file crawling
    // watchman: true,
};

File: /newrelic.js 
'use strict'
/**
 * New Relic agent configuration.
 *
 * See lib/config/default.js in the agent distribution for a more complete
 * description of configuration variables and their potential values.
 */
exports.config = {
  /**
   * Array of application names.
   */
  // app_name: ['creator-api-websites'],
  /**
   * Your New Relic license key.
   */
  // license_key: 'license key here',
  logging: {
    /**
     * Level at which to log. 'trace' is most useful to New Relic when diagnosing
     * issues with the agent, 'info' and higher will impose the least overhead on
     * production applications.
     */
    level: 'info'
  },
  /**
   * When true, all request headers except for those listed in attributes.exclude
   * will be captured for all traces, unless otherwise specified in a destination's
   * attributes include/exclude lists.
   */
  allow_all_headers: true,
  attributes: {
    /**
     * Prefix of attributes to exclude from all destinations. Allows * as wildcard
     * at end.
     *
     * NOTE: If excluding headers, they must be in camelCase form to be filtered.
     *
     * @env NEW_RELIC_ATTRIBUTES_EXCLUDE
     */
    exclude: [
      'request.headers.cookie',
      'request.headers.authorization',
      'request.headers.proxyAuthorization',
      'request.headers.setCookie*',
      'request.headers.x*',
      'response.headers.cookie',
      'response.headers.authorization',
      'response.headers.proxyAuthorization',
      'response.headers.setCookie*',
      'response.headers.x*'
    ]
  }
}

File: /.npmrc 
registry=http://nexus.moonshot-marketing.com:8081/repository/npm-group/
init.author.name = Creator
init.author.email = creator@moonshot.co.il
email=creator@moonshot.co.il
always-auth=true
File: /.gitmodules 
[submodule "messages"]
	path = messages
	url = https://github.com/moonshot-marketing/messages.git

File: /README.md 
# creator-api-websites

### typeorm-model-generator
* https://github.com/Kononnable/typeorm-model-generator
* install: `npm i -g typeorm-model-generator`
* to generate orm models again use (in you repo) `typeorm-model-generator -h localhost -d creator -p 5432 -u creator -x creator -e postgres`


### Migration
```
-- Add Identity to PK and also fix sequence to point last
ALTER TABLE financereports 
ALTER "ID" SET NOT NULL,
ALTER "ID" ADD GENERATED ALWAYS AS IDENTITY (START WITH 2);
	
SELECT setval(pg_get_serial_sequence('financereports', 'ID'), (SELECT MAX("ID") FROM financereports)+1);



-- Fix relataions to new PK of providers
ALTER TABLE financereports
ADD COLUMN tempid integer

UPDATE financereports
SET tempid = (SELECT providers."ID" from providers WHERE providers._id = financereports."providerId")

ALTER TABLE financereports 
DROP COLUMN "providerId";

ALTER TABLE financereports 
RENAME COLUMN tempid TO "providerId";

ALTER TABLE financereports 
RENAME COLUMN "value" TO "actualPayment";

ALTER TABLE financereports
ADD COLUMN "paymentStatus" text

ALTER TABLE financereports
ADD COLUMN "accountantNote" text

-- Add new columns
ALTER TABLE financereports
ADD COLUMN "paymentMethod" text

ALTER TABLE financereports
ADD COLUMN "payerName" text

```


File: /.npmrc.backup.1749326224 
registry=http://nexus.moonshot-marketing.com:8081/repository/npm-group/
init.author.name = Creator
init.author.email = creator@moonshot.co.il
email=creator@moonshot.co.il
always-auth=true
_auth=YWRtaW46YWRtaW4xMjM=

File: /build.sh 
#!/bin/bash

sudo docker build --no-cache -t 440386026276.dkr.ecr.eu-west-2.amazonaws.com/creator-api-websites .
sudo docker push 440386026276.dkr.ecr.eu-west-2.amazonaws.com/creator-api-websites:latest

File: /.dockerignore 
node_modules
npm-debug.log
File: /.gitignore 
.idea/
node_modules/
.DS_Store
/dist
mochawesome-report/
.terraform/
output/
schema.gql
newrelic_agent.log
.env.integration
.env.prod
.yalc
yalc.lock
.env*

.codegpt
File: /package.json 
{
    "name": "creator-api-websites",
    "version": "1.0.0",
    "description": "",
    "main": "src/server.ts",
    "scripts": {
        "start": "yarn run build && PORT=2400 yarn run watch",
        "build": "rm -rf dist/migrations/scripts && yarn run build-ts",
        "build-clean-copy": "yarn run clean && yarn run build-ts && yarn run tslint && yarn run copy",
        "serve": "node dist/server.js",
        "watch": "concurrently -k -p \"[{name}]\" -n \"TypeScript,Node\" -c \"yellow.bold,cyan.bold,green.bold\"  \"yarn run watch-ts\" \"yarn run serve\"",
        "test": "NODE_ENV=test jest --runInBand --coverage --forceExit",
        "build-ts": "tsc",
        "watch-ts": "tsc -w",
        "tslint": "tslint -c tslint.json -p tsconfig.json --fix",
        "clean": "rm -r dist",
        "run": "ts-node -O '{\"module\":\"commonjs\"}' asd.ts",
        "protoc:generate:files": "protoc click.proto --plugin=./node_modules/.bin/protoc-gen-ts_proto --ts_proto_out=./src/interfaces --proto_path=../messages/valuetrack --ts_proto_opt=snakeToCamel=true --ts_proto_opt=esModuleInterop=true --ts_proto_opt=outputJsonMethods=false --ts_proto_opt=outputEncodeMethods=false",
        "load:migration:env": "node -e 'require(\"./node_modules/@moonshot-marketing/creator-server/lib/utils/LoadSsmParameters.js\").load_migration_ssm_parameters()' ",
        "load:integ:migration:env": "NODE_ENV=integration yarn load:migration:env",
        "load:prod:migration:env": "NODE_ENV=prod yarn load:migration:env",
        "swap_branches": "branch=CRD-759 && git add . && git stash && git branch $branch && git checkout $branch && git stash pop && git add . && git commit -m $branch && git push origin $branch",
        "typeorm-migration-generate-integration": "yarn load:integ:migration:env && NODE_ENV=integration ts-node node_modules/.bin/typeorm -d src/migrations/config/DataSourceConfig.ts migration:generate ./src/migrations/scripts-integration/Diff",
        "typeorm-migration-generate-prod+stg": "yarn load:prod:migration:env && NODE_ENV=prod ts-node node_modules/.bin/typeorm -d src/migrations/config/DataSourceConfig.ts migration:generate ./src/migrations/scripts-prod/Diff && cp ./src/migrations/scripts-prod/*-Diff.ts ./src/migrations/scripts-stg/",
        "typeorm-migration-up": "yarn load:integ:migration:env && NODE_ENV=integration node node_modules/.bin/typeorm -d src/migrations/config/DataSourceConfig.ts migration:run",
        "typeorm-migration-revert": "yarn load:integ:migration:env && NODE_ENV=integration node node_modules/.bin/typeorm -d src/migrations/config/DataSourceConfig.t migration:revert",
        "typeorm-migration-seed": "yarn load:integ:migration:env && NODE_ENV=integration node node_modules/.bin/typeorm -d src/migrations/config/DataSourceConfig.ts migration:run"
    },
    "repository": {
        "type": "git",
        "url": "git+https://github.com/moonshot-marketing/creator-api-websites.git"
    },
    "author": "",
    "license": "ISC",
    "bugs": {
        "url": "https://github.com/moonshot-marketing/creator-api-websites/issues"
    },
    "homepage": "https://github.com/moonshot-marketing/creator-api-websites#readme",
    "dependencies": {
        "@apollo/federation": "^0.12.1",
        "@aws-sdk/client-sfn": "^3.731.1",
        "@moonshot-marketing/creator-cloud": "^1.0.130",
        "@moonshot-marketing/creator-entities": "npm:@moonshot-marketing/creator-entities-assets-refactor",
        "@moonshot-marketing/creator-server": "^1.0.79",
        "@moonshot-marketing/creator-utils": "^1.0.40",
        "@moonshot-marketing/typeorm-graphql-loader": "^1.7.181",
        "@natgeosociety/auth0-authorization": "^1.1.2",
        "apollo-datasource": "^0.7.3",
        "apollo-datasource-rest": "^0.9.7",
        "apollo-server": "^2.22.2",
        "apollo-server-express": "^2.22.2",
        "apollo-server-types": "^0.7.0",
        "array-to-tree": "^3.3.2",
        "axios": "1.8.2",
        "class-transformer": "^0.5.1",
        "dayjs": "^1.11.13",
        "dotenv": "^8.2.0",
        "excel-date-to-js": "^1.1.5",
        "express": "5.0.0",
        "false": "^0.0.4",
        "fast-csv": "^4.3.6",
        "favicons": "^7.2.0",
        "graphql": "^15.5.0",
        "graphql-config": "^3.2.0",
        "graphql-constraint-directive": "^2.1.1",
        "graphql-middleware": "^4.0.3",
        "graphql-request": "^3.4.0",
        "graphql-upload": "^11.0.0",
        "jest-html-reporter": "^3.3.0",
        "json2csv": "^5.0.6",
        "lodash": "^4.17.21",
        "long": "^5.2.0",
        "memfs": "^3.2.0",
        "moment": "^2.29.1",
        "moment-timezone": "^0.5.37",
        "newrelic": "^12.19.0",
        "passport": "0.6.0",
        "passport-jwt": "^4.0.0",
        "pg": "^8.8.0",
        "pino": "^6.11.2",
        "prom-client": "^12.0.0",
        "ts-proto": "^1.105.2",
        "type-graphql": "^1.1.1",
        "typeorm": "^0.3.10",
        "underscore": "^1.12.1",
        "util": "^0.12.5",
        "uuid": "^8.3.2",
        "xlsx": "^0.17.0"
    },
    "devDependencies": {
        "@divyenduz/ts-graphql-plugin": "^0.1.0",
        "@types/auth0": "^2.33.3",
        "@types/chai": "^4.2.15",
        "@types/compression": "^1.7.0",
        "@types/errorhandler": "^1.5.0",
        "@types/express": "^4.16.1",
        "@types/express-fileupload": "^0.1.1",
        "@types/express-session": "^1.15.12",
        "@types/graphql-upload": "^8.0.4",
        "@types/ioredis": "^4.22.2",
        "@types/jest": "^29.5.14",
        "@types/json2csv": "^5.0.3",
        "@types/lodash": "^4.14.168",
        "@types/node": "^18.11.9",
        "@types/passport": "^1.0.6",
        "@types/passport-jwt": "^3.0.5",
        "@types/redis": "^2.8.28",
        "@types/sinon": "^9.0.11",
        "@types/underscore": "^1.11.0",
        "@types/uuid": "^8.3.0",
        "@types/xlsx": "0.0.36",
        "apollo-metrics": "^1.0.1",
        "apollo-server-testing": "^2.22.2",
        "chai": "^4.3.4",
        "chai-http": "^4.3.0",
        "deep-equal-in-any-order": "^1.0.28",
        "easygraphql-tester": "^5.1.6",
        "errorhandler": "^1.5.1",
        "graphql-type-json": "^0.3.2",
        "jest": "^29.7.0",
        "replace-in-files-cli": "^2.0.0",
        "ts-jest": "^29.2.5",
        "ts-node": "^8.10.2",
        "tslint": "^6.1.2",
        "type-graphql-filter": "^0.4.0",
        "typescript": "^4.7.4"
    }
}

File: /tslint.json 
{
  "rules": {
    "class-name": true,
    "comment-format": [
      true,
      "check-space"
    ],
    "indent": [
      true,
      "spaces"
    ],
    "one-line": [
      true,
      "check-open-brace",
      "check-whitespace"
    ],
    "no-var-keyword": true,
    "quotemark": [
      true,
      "double",
      "avoid-escape"
    ],
    "semicolon": [
      true,
      "always",
      "ignore-bound-class-methods"
    ],
    "whitespace": [
      true,
      "check-branch",
      "check-decl",
      "check-operator",
      "check-module",
      "check-separator",
      "check-type"
    ],
    "typedef-whitespace": [
      true,
      {
        "call-signature": "nospace",
        "index-signature": "nospace",
        "parameter": "nospace",
        "property-declaration": "nospace",
        "variable-declaration": "nospace"
      },
      {
        "call-signature": "onespace",
        "index-signature": "onespace",
        "parameter": "onespace",
        "property-declaration": "onespace",
        "variable-declaration": "onespace"
      }
    ],
    "no-internal-module": true,
    "no-trailing-whitespace": true,
    "no-null-keyword": false,
    "prefer-const": true,
    "jsdoc-format": true
  }
}
File: /.nvmrc 
v18.20.0

File: /.prettierrc 
{
    "printWidth": 180,
    "tabWidth": 4,
    "semi": true,
    "singleQuote": false,
    "trailingComma": "all",
    "bracketSpacing": true,
    "jsxBracketSameLine": false,
    "arrowParens": "always"
}

File: /Jenkinsfile 
@Library('jenkins-pipelines') _
creatorv2()


File: /stam2 

File: /emptymaster 

File: /tsconfig.json 
{
  "compilerOptions": {
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,
    "allowSyntheticDefaultImports": true,
    "module": "commonjs",
    "target": "es2017",
    "lib": ["es2015", "es2017.object", "dom", "es2019", "es6"],
    "noImplicitAny": true,
    "moduleResolution": "node",
    "sourceMap": true,
    "outDir": "dist",
    "baseUrl": ".",
    "allowJs": true,
    "maxNodeModuleJsDepth": 10,
    "skipLibCheck": true,
    "paths": {
      "*": [
        "node_modules/*",
        "src/types/*"
      ]
    }
  },
  "include": [
    "src/**/*",
    "src/controllers/*",
    "src/*"
  ]
}


File: /src/migrations/scripts-prod/1746342099879-Diff.ts 
import { MigrationInterface, QueryRunner } from "typeorm";

export class Diff1746342099879 implements MigrationInterface {
    name = "Diff1746342099879";

    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`ALTER TABLE "ad_serving_companies" DROP COLUMN "deleted_at"`);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`ALTER TABLE "ad_serving_companies" ADD "deleted_at" TIMESTAMP`);
    }

}

File: /src/migrations/config/DataSourceConfig.ts 
import * as Models from "@moonshot-marketing/creator-entities";
import { AppDataSource } from "@moonshot-marketing/creator-server";

export default AppDataSource(Models);

File: /src/migrations/scripts-stg/1746342099879-Diff.ts 
import { MigrationInterface, QueryRunner } from "typeorm";

export class Diff1746342099879 implements MigrationInterface {
    name = "Diff1746342099879";

    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`ALTER TABLE "ad_serving_companies" DROP COLUMN "deleted_at"`);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`ALTER TABLE "ad_serving_companies" ADD "deleted_at" TIMESTAMP`);
    }

}

File: /src/migrations/scripts-integration/1746342088394-Diff.ts 
import { MigrationInterface, QueryRunner } from "typeorm";

export class Diff1746342088394 implements MigrationInterface {
    name = "Diff1746342088394";

    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`ALTER TABLE "ad_serving_companies" DROP COLUMN "deleted_at"`);
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`ALTER TABLE "ad_serving_companies" ADD "deleted_at" TIMESTAMP`);
    }

}

File: /src/responseTypes/BulkEditResponse.ts 
import { Field, Int, ObjectType } from "type-graphql";

@ObjectType()
export class BulkEditResponse {
    @Field(() => Boolean)
    status: boolean;

    @Field(() => String)
    reason: string;

    @Field(() => Int)
    noOfModifiedAssets: number;

    public constructor(init?: Partial<BulkEditResponse>) {
        Object.assign(this, init);
    }
}

File: /src/responseTypes/RankingState.ts 
import { Field, Int, ObjectType } from "type-graphql";

@ObjectType()
export class RankingState {

    @Field(() => Boolean)
    is_running: boolean;

    @Field(() => String)
    last_upload_by: string;

    @Field(() => Int)
    website: number;

    @Field(() => Int)
    percents: number;

    @Field(() => String)
    last_upload_status: string;

    @Field(() => String)
    last_upload_time: string;
}

File: /src/responseTypes/MediaGalleryResponse.ts 
import { Field, Int, ObjectType } from "type-graphql";
import { MediaGalleryAsset } from "@moonshot-marketing/creator-entities";

@ObjectType()
export class MediaGalleryResponse {

    @Field(() => [MediaGalleryAsset])
    records: MediaGalleryAsset[];

    @Field(() => Int)
    totalCount: number;
}

File: /src/responseTypes/PublishState.ts 
import { Field, Int, ObjectType } from "type-graphql";

@ObjectType()
export class PublishState {

    @Field(() => Boolean)
    is_running: boolean;

    @Field(() => String)
    last_publish_by: string;

    @Field(() => Int)
    website: number;

    @Field(() => Int)
    percents: number;

    @Field(() => String)
    last_publish_status: string;

    @Field(() => String)
    last_publish_time: string;
}

File: /src/responseTypes/BulkEditSectionsResponse.ts 
import { Field, Int, ObjectType } from "type-graphql";

@ObjectType()
export class BulkEditSectionsResponse {
    @Field(() => Boolean)
    status: boolean;

    @Field(() => String)
    reason: string;

    @Field(() => Int)
    numOfModifiedPages: number;

    public constructor(init?: Partial<BulkEditSectionsResponse>) {
        Object.assign(this, init);
    }
}

File: /src/responseTypes/RssSportsLeaguesResponse.ts 
import { Field, Int, ObjectType } from "type-graphql";


@ObjectType()
export class RssStagesResponse {

    @Field(() => String)
    countryId: string;

    @Field(() => String)
    countryName: string;

    @Field(() => String)
    tournamentName: string;

    @Field(() => String)
    tournamentId: string;
}

@ObjectType()
export class RssSportsLeaguesResponse {

    @Field(() => Int)
    sportId: number;

    @Field(() => String)
    sportName: string;

    @Field(() => [RssLeagues])
    leagues: RssLeagues[];
}


@ObjectType()
class RssLeagues {

    @Field(() => Int)
    countryId: number;

    @Field(() => String)
    countryName: string;

    @Field(() => String)
    leagueName: string;

    @Field(() => String)
    tournamentId: string;

}

File: /src/types/IntegrationsPlatformValue.ts 
import { Currency, TimeZone } from "@moonshot-marketing/creator-entities";
import { IsEnum, IsString } from "class-validator";

export class AdsPlatformValue {
    @IsString()
    externalAccountId: string;

    @IsEnum(TimeZone)
    timeZone: TimeZone;

    @IsEnum(Currency)
    currency: Currency;
}

export class GtmPlatformValue {
    @IsString()
    gtmCode: string;
}

export class GdprPlatformValue {
    @IsString()
    gdprCode: string;
}

export class OneSignalPlatformValue {
    @IsString()
    appId: string;

    @IsString()
    apiKey: string;
}

export class SlackPlatformValue {
    @IsString()
    slackChannel: string;
}

export class GA4PlatformValue {
    @IsString()
    measurementId: string;

    @IsString()
    secretKey: string;

    @IsString()
    accountId: string;
}

export class FacebookPlatformValue {
    @IsString()
    pixelId: string;
}

export class TiktokPlatformValue {
    @IsString()
    pixelId: string;

    @IsString()
    accountId: string;
}

export class TwitterPlatformValue {
    @IsString()
    pixelId: string;

    @IsString()
    saleId: string;

    @IsString()
    obId: string;

    @IsString()
    leadId: string;

    @IsString()
    signupId: string;
}

export class TaboolaPlatformValue {
    @IsString()
    pixelId: string;
}

export class SnapchatPlatformValue {
    @IsString()
    snapchatId: string;
}

export class HotjarPlatformValue {
    @IsString()
    hotjarId: number;
}

export class ClarityPlatformValue {
    @IsString()
    clarityId: number;
}

File: /src/types/ProductCsvRow.ts 
export type ProductCsvRow = {
    product: string;
    provider: string;
    affiliate: string;
    currentPosition: number;
    newPosition: number;
};
File: /src/config/Endpoints.ts 
export const Endpoints = {
    HOSTING: {
        UPLOAD_FAVICON_FILES: "/api/assets/uploadFaviconFiles"
    },
};

File: /src/config/passport.ts 
import * as passport from "passport";
import * as passportJWT from "passport-jwt";
import * as jwt from "jsonwebtoken";
import { Roles } from "@moonshot-marketing/creator-entities";
import { GraphQLClient, gql } from "graphql-request";

export class PassportConfigurator {

    private graphQLClient = new GraphQLClient(process.env.GATEWAY_URL);

    initStrategies() {
        passport.use("jwt", new passportJWT.Strategy({
            jwtFromRequest: passportJWT.ExtractJwt.fromAuthHeaderAsBearerToken(),
            secretOrKey: process.env.JWT_SECRET
        }, async (jwt_payload, next) => {
            const token = jwt.sign(jwt_payload, process.env.JWT_SECRET);
            this.graphQLClient.setHeader("authorization", `Bearer ${token}`);
            const user = await this.graphQLClient.request(`
            query me{
                user: me{
                    email_verified
                    role
                }
            }`);
            if (this.isAuthorized(user.user)) {
                next(undefined, true);
            } else {
                next("Unauthorized", false);
            }
        }));
    }

    private isAuthorized(user: any) {
        return user && user.email_verified === true && (user.role == Roles.ADMIN || user.role == Roles.BASIC || user.role == Roles.TRUSTED);
    }


}

File: /src/utils/uploadFaviconUtils.ts 
import { CloudFrontHelper, S3FileHostingHelper } from "@moonshot-marketing/creator-cloud";

import { Website } from "@moonshot-marketing/creator-entities";
import favicons from "favicons";

export class UploadFaviconUtils {
    private readonly s3FileHostingHelper: S3FileHostingHelper = new S3FileHostingHelper();
    private readonly cloudFrontHelper: CloudFrontHelper = new CloudFrontHelper();

    async uploadFaviconImagesToS3(image: Buffer, website: Website, uploadPathDir: string = "assets/") {
        const filesPathsToInvalidate: string[] = [];
        const images = await this.generateFavicons(image);
        const s3Paths: string[] = await Promise.all(
            images.map(async (image) => {
                const relativePath = uploadPathDir + image.name;
                filesPathsToInvalidate.push(`/${relativePath}`);
                return this.s3FileHostingHelper.uploadFile(image.contents, website.bucketName, relativePath, true, undefined, true);
            }),
        );
        if (!!filesPathsToInvalidate.length) {
            this.cloudFrontHelper.invalidateFiles(website.distributionId, filesPathsToInvalidate).catch(console.error);
        }
        return s3Paths;
    }

    async generateFavicons(image: Buffer) {
        // see configuration options https://www.npmjs.com/package/favicons
        const faviconsConfig = {
            icons: {
                android: false,
                appleIcon: false,
                appleStartup: false,
                coast: false,
                favicons: true,
                firefox: false,
                windows: false,
                yandex: false,
            },
        };

        try {
            const response = await favicons(image, faviconsConfig);

            return response.images;
        } catch (error) {
            throw error;
        }
    }
}

File: /src/utils/eventBridgeUtil.ts 
import { CloudWatchEventsHelper, LambdaHelper } from "@moonshot-marketing/creator-cloud";
import * as moment from "moment-timezone";

export class EventBridgeUtil {

    private readonly cloud_watch_events_helper: CloudWatchEventsHelper;
    private readonly lambda_helper: LambdaHelper;

    constructor() {
        this.cloud_watch_events_helper = new CloudWatchEventsHelper();
        this.lambda_helper = new LambdaHelper();
    }

    async createRule(ruleName: string, targetLambdaARN: string, nextRunAt: Date, targetLambdaInputData: any) {

        const userDateTime = moment(nextRunAt, 'YYYY-MM-DD HH:mm:ss [GMT]Z');
        const scheduledDateTime = userDateTime.utc();
        const scheduleExpression = `cron(${scheduledDateTime.minute()} ${scheduledDateTime.hour()} ${scheduledDateTime.date()} ${scheduledDateTime.month() + 1} ? ${scheduledDateTime.year()})`;

        await this.cloud_watch_events_helper.put_rule(ruleName, scheduleExpression);
        await this.attachTarget(ruleName, targetLambdaARN, targetLambdaInputData);
    }

    private async attachTarget(ruleName: string, targetARN: string, inputData: any) {
        const targets = [{ Arn: targetARN, Id: ruleName, Input: JSON.stringify(inputData) }];
        return await this.cloud_watch_events_helper.put_targets(ruleName, targets);
    }

    async deleteRule(ruleName: string, targetLambdaARN: string) {
        await this.removeTarget(ruleName, targetLambdaARN);
        return await this.cloud_watch_events_helper.delete_rule(ruleName, true);
    }

    private async removeTarget(ruleName: string, targetARN: string) {
        return await this.cloud_watch_events_helper.remove_targets(ruleName, true);
    }

    async disableRule(name: string) {
        return await this.cloud_watch_events_helper.disable_rule(name);
    }

    async enableRule(name: string) {
        return await this.cloud_watch_events_helper.enable_rule(name);
    }

    private async getRuleTime(date: any, unit: any, interval: any) {
        let ret = new Date(date); // don't change original date
        switch (unit.toLowerCase()) {
            case "year": ret.setFullYear(ret.getFullYear() + interval); break;
            case "quarter": ret.setMonth(ret.getMonth() + 3 * interval); break;
            case "month": ret.setMonth(ret.getMonth() + interval); break;
            case "week": ret.setDate(ret.getDate() + 7 * interval); break;
            case "day": ret.setDate(ret.getDate() + interval); break;
            case "hour": ret.setTime(ret.getTime() + interval * 3600000); break;
            case "minute": ret.setTime(ret.getTime() + interval * 60000); break;
            case "second": ret.setTime(ret.getTime() + interval * 1000); break;
            default: ret = undefined; break;
        }
        return moment(ret.toUTCString()).tz("Israel");
    }

    private async attachPermission(rule_name: string, source_arn: string, target_arn: string) {
        await this.lambda_helper.add_permission(target_arn, source_arn, rule_name);
    }

}
File: /src/utils/generateFilterTypeCustomParser.ts 
const parseFilternType = (filter: string) => {
    if (filter.endsWith("_in")) {
        const split = filter.split("_in");
        return {prop: split[0], filter: "in"};
    } else if (filter.endsWith("_eq")) {
        const split = filter.split("_eq");
        return {prop: split[0], filter: "="};
    }  else if (filter.endsWith("_ne")) {
        const split = filter.split("_ne");
        return {prop: split[0], filter: "!="};
    } else {
        return undefined;
    }
};

export const generateFilterTypeCustomParser = (filter: any, aggregated: string, mapper: any = (x: any, key: any, operation: any) => x) => {
    const parsed = [];
    if (!!aggregated) {
        parsed.push(aggregated);
    }
    if (!!filter) {
        for (const prop of Object.keys(filter)) {
            const res = parseFilternType(prop);
            if (!!res) {
                const selections = mapper(filter[prop], res.prop, res.filter);
                parsed.push(`${res.prop} ${res.filter} ${selections}`);
            }
        }
    }
    return parsed;
};
File: /src/utils/ProductRankingFileUtils.ts 
import { Website, Product } from "@moonshot-marketing/creator-entities";
import { S3FileHostingHelper } from "@moonshot-marketing/creator-cloud";
import * as _ from "lodash";
import { PassThrough } from "stream";
import { ProductRankingRow } from "../interfaces/ProductRankingRow";
import * as moment from "moment";

export class ProductRankingFileUtils {

    static async get_csv_rows(website_id: number, active_providers: boolean, products_ids: number[]): Promise<{ domain: string, rows: ProductRankingRow[]}> {
        const website = await Website.findOne({ where: { id: website_id } });
        if (!website) {
            throw new Error("Website Not Exists");
        }

        const main_query = Product.createQueryBuilder("products")
            .leftJoinAndSelect("products.providers", "product_provider")
            .leftJoinAndSelect("product_provider.provider", "provider")
            .leftJoinAndSelect("product_provider.affiliate", "affiliate")
            .where(`products."websiteId" = :website_id`, { website_id })
            .andWhere(`affiliate.id is not null`)
            .andWhere(`provider.id is not null`)
            .groupBy(`products.name, affiliate.name, provider.id, provider.name, product_provider.index`)
            .select(`products.name as product`)
            .addSelect(`affiliate.name as outbound`)
            .addSelect(`provider.id as "providerId"`)
            .addSelect(`provider.name as "providerName"`)
            .addSelect(`product_provider.index as "currentPosition"`)
            .addSelect(`product_provider.index as "newPosition"`);

        if (active_providers) {
            main_query
                .leftJoin("provider.componentsProviders", "components_providers")
                .andWhere(`components_providers.id is not null`);
        }

        if (products_ids.length) {
            main_query.andWhere("products.id IN (:...products_ids)", { products_ids });
        }

        const rows = await main_query.getRawMany<ProductRankingRow>();

        return { domain: website.domain, rows };

    }

    static async upload_csv(rows: ProductRankingRow[], domain: string): Promise<string> {
        const columns = ["product", "outbound", "providerId", "providerName", "currentPosition", "newPosition"];
        const write_stream = new PassThrough();
        write_stream.write(columns.join(",") + "\n");

        for (const row of rows) {
            const csv_row = this.get_csv_row(row, columns);
            write_stream.write(csv_row);
        }

        return await this.close_write_stream(write_stream, domain);
    }

    private static get_csv_row(row: ProductRankingRow, columns: string[]) {
        let csv_row = "";
        for (const column of columns) {
            const value = _.get(row, column, "");
            csv_row += `"${value}",`;
        }
        csv_row = csv_row.slice(0, -1);
        return csv_row + "\n";
    }

    private static async close_write_stream(write_stream: PassThrough, domain: string) {
        const date = moment().format("YYYY-MM-DD-HH-mm");
        const key = `${domain}/${date}/ProductRankingFileEdit.csv`;
        const file_hosting = new S3FileHostingHelper();
        write_stream.end();
        await file_hosting.upload(process.env.PRODUCT_RANKING_BUCKET, key, write_stream, true);
        return `https://${process.env.PRODUCT_RANKING_BUCKET}.s3.eu-west-2.amazonaws.com/${key}`;
    }
}

File: /src/utils/dynamoUtil.ts 
import { DynamoHelper } from "@moonshot-marketing/creator-cloud";
import * as _ from "lodash";


export class DynamoUtil {
    async removeDynamoRowsInBatch(tableName: string, dynamoParams: any[]) {

        for (const param of _.chunk(dynamoParams, 25)) {
            const batchParams: any = { RequestItems: {} };
            batchParams.RequestItems[tableName] = param;
            if (!!param.length) {
                const dynamoHelper = new DynamoHelper();
                await dynamoHelper.writeBatchItems(batchParams);
            }
        }
    }

    async getDeleteDynamoRowParam(key: string) {
        const batchParam: any = { DeleteRequest: { Key: {} } };
        batchParam.DeleteRequest.Key["key"] = { S: key };
        return batchParam;
    }

    async removeMapKeyFromDynamoRow(tableName: string, key: string, mapKey: string) {
        const params = {
            TableName: tableName,
            Key: {
                key: {
                    S: key
                }
            },
            UpdateExpression: `REMOVE #parent.#key`, // Here. Note: use `` instead of '',
            ExpressionAttributeNames: {
                "#parent": "document",
                "#key": mapKey
            },
            ReturnValues: "ALL_NEW"
        };

        const dynamoHelper = new DynamoHelper();
        await dynamoHelper.updateItemByParams(params);
    }
}
File: /src/utils/cookieHandler.ts 
export class CookieHandler {

    get(cookieName: string) { return ""; }

    put(cookieName: string, cookieValue: any, ttl: Date) { return true; }

    isCookiesEnabled() { return false; }
}

File: /src/utils/OneSignalKeyGenerator.ts 
import { SecretKeyGenerator } from "@moonshot-marketing/creator-cloud";

export class OneSignalKeyGenerator implements SecretKeyGenerator {
    generate = (key: string) => `${process.env.AWS_SECRET_MANAGER_PREFIX}${key}`;
}
File: /src/utils/mediaGalleryUtils.ts 
export class MediaGalleryUtil {

    static async getImageHandlerUrl(path: string) {
        const domainRegex = /.+?.s3.eu-west-2.amazonaws.com+/g;
        const assetRegex = /s3.eu-west-2.amazonaws.com(.+?)+/g;

        const domain = path.match(domainRegex);
        const asset = path.match(assetRegex);

        if (domain && asset) {
            const domainStr = domain[0]?.replace("https://", "")?.replace(".s3.eu-west-2.amazonaws.com", "");
            const assetStr = asset[0]?.replace("s3.eu-west-2.amazonaws.com", "");
            return `https://${process.env.IMAGE_HANDLER}/s3:${domainStr}${assetStr}/fit-in/`;
        } else {
            return path;
        }

    }

    static async resizer(path: string) {
        const domainRegex = /.+?.s3.eu-west-2.amazonaws.com+/g;
        const assetRegex = /s3.eu-west-2.amazonaws.com(.+?)+/g;

        const domain = path.match(domainRegex);
        const asset = path.match(assetRegex);

        if (domain && asset) {
            const domainStr = domain[0]?.replace("https://", "")?.replace(".s3.eu-west-2.amazonaws.com", "");
            const assetStr = asset[0]?.replace("s3.eu-west-2.amazonaws.com", "");
            return `/resizer/s3:${domainStr}${assetStr}/fit-in/`;
        } else {
            return path;
        }

    }
}

File: /src/utils/providerListsUtil.ts 
import { ProviderLists, Website } from "@moonshot-marketing/creator-entities/lib";

export const createDefaultProviderList = (website: Website) => {
    const providerList = new ProviderLists();

    Object.assign(providerList, {
        listId: "list-1",
        nickName: "list-1",
        website,
    });

    return providerList;
};

File: /src/resolvers/SourcesResolver.ts 
import {
    CompanyTypes,
    PageState,
    Roles,
    Source,
    SourceType,
    Website,
    WebsitePage
} from "@moonshot-marketing/creator-entities";
import { GraphQLError, GraphQLResolveInfo } from "graphql";
import { SourceInput } from "../inputs/SourceInput";
import { Arg, Authorized, Ctx, Info, Int, Mutation, Query, Resolver } from "type-graphql";
import { UpdateSourceInput } from "../inputs/UpdateSourceInput";
import axios from "axios";

@Resolver(() => Source)
export class SourcesResolver {

    @Authorized<Roles>([Roles.BASIC, Roles.TRUSTED, Roles.ADMIN, Roles.UNTRUSTED])
    @Query(() => [Source], { name: "source" })
    async read(
        @Ctx() context: any,
        @Info() info: GraphQLResolveInfo,
        @Arg("ids", () => [Int], { nullable: true }) ids?: [number]
    ): Promise<Source[] | Source> {

        const whereExpressions: string[] = [];
        if (!!ids && ids.length) {
            whereExpressions.push(`source.id IN (${ids})`);
        }
        const where = whereExpressions.join(" AND ");
        return await context.loader
            .loadEntity(Source, "source")
            .where(where)
            .info(info)
            .loadMany();
    }

    @Authorized<Roles>([Roles.BASIC, Roles.TRUSTED, Roles.ADMIN])
    @Mutation(() => Boolean, { name: "deleteSource" })
    async delete(@Arg("ids", () => [Int]!) ids: number[]): Promise<boolean> {
        await Source.delete(ids);
        return true;
    }

    @Authorized<Roles>([Roles.BASIC, Roles.TRUSTED, Roles.ADMIN])
    @Mutation(() => [Source], { name: "createSource" })
    async create(@Arg("data", () => [SourceInput], { validate: true }) sourceInput: SourceInput[]): Promise<Source[]> {
        const website: Website = await Website.findOne({ where: { id: sourceInput[0].website }}); // sources array always for the same website
        await this.sync_actions(sourceInput, website);
        await WebsitePage.update({ website: { id: website.id } }, { state: PageState.UNPUBLISHED });
        const sourcesToSave = sourceInput.map(function (el) { const source: Source = new Source(); Object.assign(source, el); return source; });
        return await Source.save(sourcesToSave);
    }

    @Authorized<Roles>([Roles.BASIC, Roles.TRUSTED, Roles.ADMIN])
    @Mutation(() => [Source], { name: "updateSource" })
    async update(@Arg("data", () => [UpdateSourceInput], { validate: true }) sourceInput: UpdateSourceInput[]): Promise<Source[]> {
        const website: Website = await Website.findOne({ where: { id: sourceInput[0].website }}); // sources array always for the same website
        await this.sync_actions(sourceInput, website);
        const sourcesToSave = sourceInput.map(function (el) { const source: Source = new Source(); Object.assign(source, el); return source; });
        return await Source.save(sourcesToSave);
    }

    private async sync_actions(sources: SourceInput[], website: Website) {
        const requests = [];
        const google_bing_sources = sources.filter(source => [SourceType.BING, SourceType.GOOGLE].includes(source.type));
        for (const source of google_bing_sources) {
            const request = {
                externalAccountId: source.externalAccountId,
                timeZone: source.timeZone,
                currency: source.currency,
                enabled: source.enabled,
                type: SourceType[source.type],
                websiteId: source.website,
                is_af: website.companyType === CompanyTypes.AF,
                mcc_name: website.companyType
            };
            if (source.createConversion) {
                requests.push(axios.get(process.env.CONVERSION_ACTION_CREATION_URL, { data: request }));
            }
        }
        if (!!requests.length) {
            try {
                await Promise.all(requests);
            } catch (error) {
                throw new GraphQLError(error);
            }
        }
    }

}

File: /src/resolvers/WebsiteResolver.ts 
import { UpdateDistributionCommandInput } from "@aws-sdk/client-cloudfront";
import { CloudFrontHelper, DynamoHelper, LambdaHelper, S3FileHostingHelper, SecretsManagerHelper, SecretsManagerHelperV2, SnsGeneric, StepFunctionsHelper } from "@moonshot-marketing/creator-cloud";
import {
    AssetLevel,
    AuditTrail,
    ComponentAsset,
    GlobalVerticalAsset,
    MediaGalleryAsset,
    PageAsset,
    PageState,
    PageStatus,
    PageType,
    Provider,
    Roles,
    Segment,
    SegmentStatus,
    Template,
    TemplateAsset,
    TemplatePage,
    TemplatePageComponent,
    User,
    Website,
    WebsiteFilter,
    WebsiteGlobalVertical,
    WebsitePage,
    WebsitePageComponent,
    WebsiteStrategy,
    WebsiteUtils,
    WebsiteVertical,
} from "@moonshot-marketing/creator-entities";
import { Context } from "@moonshot-marketing/creator-server";
import { FileUtils, SlackNotification } from "@moonshot-marketing/creator-utils";
import axios, { AxiosRequestConfig } from "axios";
import { GraphQLResolveInfo } from "graphql";
import { Redis } from "ioredis";
import * as _ from "lodash";
import { fs } from "memfs";
import { Readable } from "stream";
import { Arg, Args, Authorized, Ctx, FieldResolver, Info, Int, Mutation, Query, Resolver, Root, UseMiddleware } from "type-graphql";
import { DataSource, In, IsNull, Not, SelectQueryBuilder } from "typeorm";
import { v4 as uuidv4 } from "uuid";
import { GetWebsiteArgs } from "../argsTypes/GetWebsiteArgs";
import { OrderArgs } from "../argsTypes/OrderArgs";
import { CreateWebsiteInput } from "../inputs/CreateWebsiteInput";
import { InsertWebsiteInput } from "../inputs/InsertWebsiteInput";
import { UpdateWebsiteInput } from "../inputs/UpdateWebsiteInput";
import { UpdateWebsiteVisitorsCounterInput } from "../inputs/UpdateWebsiteVisitorsCounterInput";
import { WebsiteFilterInput } from "../inputs/WebsiteFilter/WebsiteFilterInput";
import { PublishState } from "../responseTypes/PublishState";
import { RankingState } from "../responseTypes/RankingState";
import { RssSportsLeaguesResponse, RssStagesResponse } from "../responseTypes/RssSportsLeaguesResponse";
import { OneSignalKeyGenerator } from "../utils/OneSignalKeyGenerator";
import { createDefaultProviderList } from "../utils/providerListsUtil";
import { UploadFaviconUtils } from "../utils/uploadFaviconUtils";
import GraphQLJSON from "graphql-type-json";
const templateRelations = [
    "providerAssets",
    "globalAssets",
    "pages",
    "pages.assets",
    "pages.templatePageComponents",
    "pages.templatePageComponents.component",
    "pages.templatePageComponents.component.assets",
];

@Resolver(() => Website)
export class WebsiteResolver {
    private readonly s3FileHostingHelper: S3FileHostingHelper;
    private readonly uploadFaviconUtils: UploadFaviconUtils;
    private readonly secretsManager: SecretsManagerHelper;
    private readonly snsClient: SnsGeneric;
    private readonly dynamo_helper: DynamoHelper;
    private readonly cloudFrontHelper: CloudFrontHelper = new CloudFrontHelper();
    private readonly stepFunctionsHelper: StepFunctionsHelper = new StepFunctionsHelper();

    constructor() {
        this.s3FileHostingHelper = new S3FileHostingHelper();
        this.dynamo_helper = new DynamoHelper("eu-west-2");
        this.uploadFaviconUtils = new UploadFaviconUtils();
        this.secretsManager = new SecretsManagerHelper(new OneSignalKeyGenerator());
        this.snsClient = new SnsGeneric(); // For slack notify
        this.stepFunctionsHelper = new StepFunctionsHelper();
    }

    @Authorized<Roles>([Roles.BASIC, Roles.TRUSTED, Roles.ADMIN, Roles.UNTRUSTED])
    @Query(() => [Website], { name: "website" })
    async read(
        @Ctx() context: any,
        @Info() info: GraphQLResolveInfo,
        @Args()
        {
            ids,
            dnsVerificationStatus,
            domains,
            ignoreTestPages,
            pageType,
            componentName,
            ignoreArchivePages,
            isExternal,
            uploadSales,
            salesforceIds,
            pageState,
            pageStatus,
        }: GetWebsiteArgs,
        @Args() { field, action }: OrderArgs,
    ): Promise<Website[]> {
        const whereExpressions: string[] = [];
        if (!!ids && ids.length) {
            whereExpressions.push(`website.id IN (${ids})`);
        }

        if (!!domains && domains.length) {
            whereExpressions.push(`website.domain IN ('${domains.join("','")}')`);
        }

        if (!!dnsVerificationStatus) {
            whereExpressions.push(`website.dns_verification_status = '${dnsVerificationStatus}'`);
        }

        if (!!isExternal) {
            whereExpressions.push(`website.is_external = false`);
            whereExpressions.push(`website.status = 'ACTIVE'`);
        }

        if (!!salesforceIds?.length) {
            whereExpressions.push(`website.salesforce_id IN ('${salesforceIds.join("','")}')`);
        }

        const where = whereExpressions.join(" AND ");
        const order: any = {};
        if (!!field && !!action) {
            order[`website.${field}`] = action;
        }

        const relation_where_expressions: {
            [table_name: string]: { [relation_name: string]: string };
        } = { website: {} };

        if (!!ignoreTestPages) {
            relation_where_expressions["website"]["pages"] = `pages.type not in ('${PageType.TEST}', '${PageType.TEST_ON_ASSET}', '${PageType.TEST_ON_FUNNEL}')`;
            relation_where_expressions["website"]["pages"] += ` AND pages.status != '${PageStatus.MERGED}'`;
        }

        if (!!ignoreArchivePages) {
            if (!!relation_where_expressions["website"]["pages"]) {
                relation_where_expressions["website"]["pages"] += ` AND pages.status != '${PageStatus.ARCHIVED}'`;
            } else {
                relation_where_expressions["website"]["pages"] = `pages.status != '${PageStatus.ARCHIVED}'`;
            }
        }

        if (!!pageType) {
            if (!!relation_where_expressions["website"]["pages"]) {
                relation_where_expressions["website"]["pages"] += ` AND pages.type = '${pageType}'`;
            } else {
                relation_where_expressions["website"]["pages"] = `pages.type = '${pageType}'`;
            }
        }

        if (!!pageState) {
            if (!!relation_where_expressions["website"]["pages"]) {
                relation_where_expressions["website"]["pages"] += ` AND pages.state = '${pageState}'`;
            } else {
                relation_where_expressions["website"]["pages"] = `pages.state = '${pageState}'`;
            }
        }

        if (!!pageStatus) {
            if (!!relation_where_expressions["website"]["pages"]) {
                relation_where_expressions["website"]["pages"] += ` AND pages.status = '${pageStatus}'`;
            } else {
                relation_where_expressions["website"]["pages"] = `pages.status = '${pageStatus}'`;
            }
        }

        if (!!relation_where_expressions["website"]["pages"]) {
            relation_where_expressions["website"]["pages"] += `AND ((website.websiteStrategy = 'SEGMENTS' AND pages.isLayout = true)
            OR ((website.websiteStrategy = 'PAGES' OR website.websiteStrategy is null) AND (pages.isLayout is null OR pages.isLayout != true)))`;
        } else {
            relation_where_expressions["website"]["pages"] = `((website.websiteStrategy = 'SEGMENTS' AND pages.isLayout = true)
            OR ((website.websiteStrategy = 'PAGES' OR website.websiteStrategy is null) AND (pages.isLayout is null OR pages.isLayout != true)))`;
        }

        if (!!componentName) {
            relation_where_expressions["website"]["components"] = `components.name = '${componentName}'`;
        }

        const result: { port: string; template: string; topic: string }[] = await this.dynamo_helper.scanTable({ TableName: process.env.DYNAMO_PUBLISH_READINESS });
        context.live_versions_map = _.keyBy(result, "template");
        if (!!ids?.length) {
            await this.set_websites_publish_state(context, ids);
            await this.set_websites_ranking_upload_state(context, ids);
        }

        const query = context.loader.loadEntity(Website, "website").where(where).relation_where(relation_where_expressions).info(info).order(order);

        if (!!uploadSales) {
            const lastDay = new Date();
            lastDay.setHours(lastDay.getHours() - 20); // daily notify at 20:00, checking from 00:00 last day
            query.ejectQueryBuilder((qb: SelectQueryBuilder<Website>) =>
                qb
                    .leftJoinAndSelect(
                        "reports_history",
                        "reports_history",
                        `website.id = reports_history."websiteId" and reports_history.created_at = (select max(reports_history.created_at) from reports_history where reports_history."websiteId" = website.id)`,
                    )
                    .where(`reports_history.createdAt < '${lastDay.toISOString()}'`),
            );
        }
        return await query.loadMany();
    }

    @Authorized<Roles>([Roles.BASIC, Roles.TRUSTED, Roles.ADMIN, Roles.UNTRUSTED])
    @Query(() => [String], { name: "getWebsiteSections" })
    async getWebsiteSections(@Arg("websiteId", () => Int, { nullable: false }) website_id: number): Promise<string[]> {
        const sections = await WebsitePage.createQueryBuilder("websites_pages")
            .leftJoinAndSelect("websites_pages.components", "sections")
            .select("distinct sections.name", "section_name")
            .where(`websites_pages."websiteId" = ${website_id}`)
            .getRawMany();
        return sections.map((section) => section.section_name);
    }

    @FieldResolver(() => String)
    async publishState(@Ctx() context: Context, @Root() website: Website): Promise<string> {
        const redis_result: string = await (<Redis>context.dataSources.redisClient).get(`${website.id}`);
        return !!redis_result ? redis_result : "NOT_FOUND_PUBLISH";
    }

    @Authorized<Roles>([Roles.BASIC, Roles.TRUSTED, Roles.ADMIN, Roles.UNTRUSTED])
    @Query(() => Website, { name: "websiteByPageId" })
    async readByPageId(
        @Ctx() context: any,
        @Info() info: GraphQLResolveInfo,
        @Arg("pageId", () => Int!) pageId: number,
        @Arg("ignoreTestPages", () => Boolean) ignoreTestPages?: boolean,
        @Arg("ignoreArchivePages", () => Boolean) ignoreArchivePages?: boolean,
    ): Promise<Website> {
        const query = await Website.createQueryBuilder("website")
            .leftJoin("website.pages", "main_page", `main_page.id = ${pageId}`)
            .leftJoinAndSelect("website.pages", "pages")
            .where(`website.id = main_page."websiteId"`);

        if (!!ignoreTestPages) {
            query.andWhere(`pages.type Not In ('${PageType.TEST_ON_ASSET}', '${PageType.TEST_ON_FUNNEL}', '${PageType.TEST_ON_PAGE}')`);
            query.andWhere(`pages.status != '${PageStatus.MERGED}'`);
        }
        if (!!ignoreArchivePages) {
            query.andWhere(`pages.status != '${PageStatus.ARCHIVED}'`);
        }
        return await query.getOne();
    }

    @Authorized<Roles>([Roles.ADMIN])
    @Mutation(() => Boolean, { name: "deleteWebsite" })
    async delete(@Arg("ids", () => [Int]!) ids: number[]): Promise<boolean> {
        await Website.delete(ids);
        return true;
    }

    @Authorized<Roles>([Roles.ADMIN])
    @Mutation(() => Website, { name: "storeWebsite" })
    async create(
        @Ctx() context: any,
        @Info() info: GraphQLResolveInfo,
        @Arg("data", () => InsertWebsiteInput, { validate: true }) websitesInput: InsertWebsiteInput,
    ): Promise<Website> {
        const creatingUserId = context?.user?.id;
        const website = new Website();
        Object.assign(website, websitesInput);

        if (!!creatingUserId) {
            Object.assign(website, { owner: { id: creatingUserId } });
            Object.assign(website, { usersPermitted: [{ id: creatingUserId }] });
            if (!!websitesInput.usersPermitted && !websitesInput.usersPermitted?.find((user) => user.id === creatingUserId)) {
                websitesInput.usersPermitted.push({ id: creatingUserId } as User);
            }
        }
        const templateRelations = ["providerAssets", "globalAssets"];
        const template = await Template.findOne({
            where: { id: websitesInput.template },
            relations: templateRelations,
            loadRelationIds: { relations: ["pages"] },
        });
        const templatePagesRelations = ["assets", "templatePageComponents", "templatePageComponents.component", "templatePageComponents.component.assets"];
        template.pages = await TemplatePage.find({
            where: { id: In(template.pages) },
            relations: templatePagesRelations,
        });
        const defaultGlobalWebsiteVertical = new WebsiteGlobalVertical();
        defaultGlobalWebsiteVertical.isDefault = true;
        defaultGlobalWebsiteVertical.name = "Default";
        await defaultGlobalWebsiteVertical.save();
        const websiteGlobalVerticalAssets = this.get_website_global_vertical_assets(template, defaultGlobalWebsiteVertical);
        defaultGlobalWebsiteVertical.assets = await GlobalVerticalAsset.save(websiteGlobalVerticalAssets);

        const defaultProviderVertical = new WebsiteVertical();
        defaultProviderVertical.isDefault = true;
        defaultProviderVertical.name = "Default";
        await defaultProviderVertical.save();

        website.pages = this.getWebsitePages(template.pages, template.providerAssets, defaultGlobalWebsiteVertical.id, defaultProviderVertical.id, website.websiteStrategy);

        await WebsitePage.save(website.pages);

        website.verticals = [defaultProviderVertical];
        website.globalVerticals = [defaultGlobalWebsiteVertical];

        if (website.websiteStrategy === WebsiteStrategy.SEGMENTS) {
            const defaultSegment = await this.createDefaultSegment(website, defaultProviderVertical, defaultGlobalWebsiteVertical);
            website.segments = [defaultSegment];

            await Segment.save(defaultSegment);

            website.providerLists = [createDefaultProviderList(website)];
        }

        await Website.save(website);
        return await context.loader.loadEntity(Website, "website").where(`website.id = ${website.id}`).info(info).loadOne();
    }

    @Authorized<Roles>([Roles.ADMIN])
    @Mutation(() => Boolean, { name: "createWebsite" })
    async createWebsite(@Ctx() context: any, @Arg("data", () => CreateWebsiteInput, { validate: true }) createWebsiteInput: CreateWebsiteInput) {
        await this.stepFunctionsHelper.StartExecutionCommand(process.env.CREATE_WEBSITE_STEP_FUNCTION_ARN, {
            subscriptionChannel: context?.user?.email,
            userAccessToken: context?.token,
            userEmail: context?.user?.email,
            website: createWebsiteInput,
        });

        return true;
    }

    // todo OneSignal methods to new resolver
    @Authorized<Roles>([Roles.BASIC, Roles.TRUSTED, Roles.ADMIN, Roles.UNTRUSTED])
    @Mutation(() => Boolean, { name: "createOneSignalParameters" })
    async createOneSignalParameters(
        @Ctx() context: any,
        @Info() info: GraphQLResolveInfo,
        @Arg("websiteId", () => Int!) websiteId: number,
        @Arg("oneSignalAppId", () => String!) oneSignalAppId: string,
        @Arg("oneSignalApiKey", () => String!) oneSignalApiKey: string,
    ): Promise<boolean> {
        const website = await Website.findOne({ where: { id: websiteId } });
        website.oneSignalAppId = oneSignalAppId;
        const result = await this.secretsManager.createOrUpdateSecret(oneSignalAppId, oneSignalApiKey, websiteId);
        await website.save();
        return result;
    }

    @Authorized<Roles>([Roles.BASIC, Roles.TRUSTED, Roles.ADMIN, Roles.UNTRUSTED])
    @Mutation(() => Boolean, { name: "updateOneSignalParameters" })
    async updateOneSignalParameters(
        @Ctx() context: any,
        @Info() info: GraphQLResolveInfo,
        @Arg("websiteId", () => Int!) websiteId: number,
        @Arg("oneSignalApiKey", () => String!) oneSignalApiKey: string,
    ): Promise<boolean> {
        const website = await Website.findOne({ where: { id: websiteId } });
        await website.save();
        return await this.secretsManager.updateSecret(website.oneSignalAppId, oneSignalApiKey);
    }

    @Authorized<Roles>([Roles.BASIC, Roles.TRUSTED, Roles.ADMIN, Roles.UNTRUSTED])
    @Mutation(() => Boolean, { name: "deleteOneSignalParameters" })
    async deleteOneSignalParameters(@Ctx() context: any, @Info() info: GraphQLResolveInfo, @Arg("websiteId", () => Int!) websiteId: number): Promise<boolean> {
        const website = await Website.findOne({ where: { id: websiteId } });
        const oneSignalAppId = website.oneSignalAppId;
        await this.secretsManager.deleteSecret(oneSignalAppId);
        website.oneSignalAppId = "";
        await website.save();
        return true;
    }

    @Authorized<Roles>([Roles.BASIC, Roles.TRUSTED, Roles.ADMIN, Roles.UNTRUSTED])
    @Query(() => String, { name: "getOneSignalDescription" })
    async getOneSignalDescription(@Ctx() context: any, @Info() info: GraphQLResolveInfo, @Arg("websiteId", () => Int!) websiteId: number): Promise<string> {
        const website = await Website.findOne({ where: { id: websiteId } });
        return this.secretsManager.getSecretDescription(website.oneSignalAppId);
    }

    @Authorized<Roles>([Roles.BASIC, Roles.TRUSTED, Roles.ADMIN, Roles.UNTRUSTED])
    @Query(() => [RssSportsLeaguesResponse], { name: "getRssSportsLeagues" })
    async getRssSportsLeagues(): Promise<RssSportsLeaguesResponse[]> {
        const { Body } = await this.s3FileHostingHelper.getObject(process.env.RSS_BUCKET, "sport_leagues.json");
        const res = await FileUtils.streamToString(Body as Readable);
        return JSON.parse(res);
    }

    @Authorized<Roles>([Roles.BASIC, Roles.TRUSTED, Roles.ADMIN, Roles.UNTRUSTED])
    @Query(() => GraphQLJSON, { name: "getRssStages" })
    async getRssStages(): Promise<{ [key: string]: RssStagesResponse[] }> {
        const secret_manager_helper = new SecretsManagerHelperV2("eu-west-2");
        const rapid_api_key = await secret_manager_helper.getSecretValue("RAPID_API_KEY");

        const soccer_options: AxiosRequestConfig = {
            method: "get",
            url: process.env.RAPID_FLASHLIVE_STAGES_API,
            params: { locale: "en_INT", sport_id: "1" },
            headers: {
                "x-rapidapi-key": rapid_api_key,
                "x-rapidapi-host": process.env.RAPID_HOST
            }
        };

        const tennis_options: AxiosRequestConfig = {
            method: "get",
            url: process.env.RAPID_FLASHLIVE_STAGES_API,
            params: { locale: "en_INT", sport_id: "2" },
            headers: {
                "x-rapidapi-key": rapid_api_key,
                "x-rapidapi-host": process.env.RAPID_HOST
            }
        };

        const basketball_options: AxiosRequestConfig = {
            method: "get",
            url: process.env.RAPID_FLASHLIVE_STAGES_API,
            params: { locale: "en_INT", sport_id: "3" },
            headers: {
                "x-rapidapi-key": rapid_api_key,
                "x-rapidapi-host": process.env.RAPID_HOST
            }
        };


        const soccer_response = await axios.request(soccer_options);
        const basketball_response = await axios.request(basketball_options);
        const tennis_response = await axios.request(tennis_options);
        const result: { [key: string]: RssStagesResponse[] } = {
            "SOCCER": [],
            "TENNIS": [],
            "BASKETBALL": [],
            "HORSE_RACING": [],
        };

        const countries_set = new Map<string, string>();

        for (const { COUNTRY_ID, COUNTRY_NAME, LEAGUE_NAME, GROUP_ID } of soccer_response.data.DATA) {
            result["SOCCER"].push({ countryId: COUNTRY_ID, countryName: COUNTRY_NAME, tournamentName: LEAGUE_NAME, tournamentId: GROUP_ID });
            countries_set.set(COUNTRY_ID, COUNTRY_NAME);
        }

        for (const { COUNTRY_ID, COUNTRY_NAME, LEAGUE_NAME, GROUP_ID } of basketball_response.data.DATA) {
            result["BASKETBALL"].push({ countryId: COUNTRY_ID, countryName: COUNTRY_NAME, tournamentName: LEAGUE_NAME, tournamentId: GROUP_ID });
        }

        for (const { COUNTRY_ID, COUNTRY_NAME, LEAGUE_NAME, GROUP_ID } of tennis_response.data.DATA) {
            result["TENNIS"].push({ countryId: COUNTRY_ID, countryName: COUNTRY_NAME, tournamentName: LEAGUE_NAME, tournamentId: GROUP_ID });
        }

        for (const [countryId, countryName] of countries_set.entries()) {
            result["HORSE_RACING"].push({ countryId, countryName, tournamentName: undefined, tournamentId: undefined });
        }

        return result;
    }

    @Authorized<Roles>([Roles.BASIC, Roles.TRUSTED, Roles.ADMIN, Roles.UNTRUSTED])
    @Mutation(() => Website, { name: "updateWebsite" })
    async update(
        @Ctx() context: any,
        @Info() info: GraphQLResolveInfo,
        @Arg("website", () => UpdateWebsiteInput, { validate: true }) website_input: UpdateWebsiteInput,
        @Arg("shouldMarkPagesUnpublished", () => Boolean, { defaultValue: true }) mark_as_unpublished: boolean,
    ): Promise<Website> {
        const website = await Website.findOneBy({ id: website_input.id });
        if (!!website_input.faviconMediaGalleryAsset) {
            const media_asset = await MediaGalleryAsset.findOneBy({ id: website_input.faviconMediaGalleryAsset });
            const response = await axios.get(media_asset.path, { responseType: "arraybuffer" });
            const image_data = Buffer.from(response.data, "binary");
            const urls = await this.uploadFaviconUtils.uploadFaviconImagesToS3(image_data, website);
            const favicon_s3_url = urls.find((url) => url.includes("favicon.ico"));
            if (!!favicon_s3_url) {
                website.faviconUrl = `https://${website.domain}/assets/favicon.ico`;
                website.faviconS3Url = favicon_s3_url;
            } else {
                throw new Error(`Failed to upload Favicon, please contact the Creator team`);
            }

            delete website_input.faviconMediaGalleryAsset;
        }
        Object.assign(website, website_input);
        if (typeof website_input.isPublishRunning === "boolean") {
            website.isPublishRunning = website_input.isPublishRunning;
        }

        const root_documents: { index: string; error: string } = { index: undefined, error: undefined };
        if (!!website_input.rootPageId && !!website.distributionId) {
            const rootPage = await WebsitePage.findOneByOrFail({ id: website_input.rootPageId, website: { id: website_input.id } });
            const index_root_document = `${rootPage.path.replace(".html", "")}.html`;
            if (index_root_document != website.rootPage) {
                website.rootPage = index_root_document;
                root_documents.index = index_root_document.replace("/", "");
            }
        }

        if (!!website_input.errorRootPageId) {
            const errorRootPage = await WebsitePage.findOneByOrFail({ id: website_input.errorRootPageId, website: { id: website_input.id } });
            const error_root_document = `${errorRootPage.path.replace(".html", "")}.html`;
            if (error_root_document != website.rootPage) {
                website.errorRootPage = error_root_document;
                root_documents.error = error_root_document;
            }
        }

        if (root_documents.index || root_documents.error) {
            const index = root_documents.index || "index.html";
            const s3_index = root_documents.index || "real_index.html";
            const error = root_documents.error || "/error.html";
            const distribution = await this.cloudFrontHelper.get_distribution(website.distributionId);
            distribution.DistributionConfig.DefaultRootObject = index;
            if (!!distribution.DistributionConfig.CustomErrorResponses?.Items.length) {
                for (const error_item of distribution.DistributionConfig.CustomErrorResponses.Items) {
                    error_item.ResponsePagePath = error;
                }
            } else {
                distribution.DistributionConfig.CustomErrorResponses = {
                    Items: [
                        { ErrorCode: 404, ResponsePagePath: error, ResponseCode: "404", ErrorCachingMinTTL: 300 },
                        { ErrorCode: 403, ResponsePagePath: error, ResponseCode: "403", ErrorCachingMinTTL: 300 },
                    ],
                    Quantity: 2,
                };
            }
            const update_input: UpdateDistributionCommandInput = { Id: website.distributionId, DistributionConfig: distribution.DistributionConfig, IfMatch: distribution.ETag };
            await this.cloudFrontHelper.update_distribution(update_input);
            await this.s3FileHostingHelper.updateBucketToStaticWebsite(website.bucketName, s3_index, error.replace("/", ""));
        }

        await website.save();
        if (!!mark_as_unpublished) {
            await this.markPagesUnpublished([website]);
        }
        if (!!website_input.websiteVisitorsCounter) {
            await this.updateVisitorsTable(website.domain, website_input.websiteVisitorsCounter);
        }

        return await context.loader.loadEntity(Website, "website").where(`website.id = ${website_input.id}`).info(info).loadOne();
    }

    @Authorized<Roles>([Roles.BASIC, Roles.TRUSTED, Roles.ADMIN])
    @Mutation(() => [Website], { name: "createPublishIntegrationTestPages" })
    async createPublishIntegrationTestPages(@Ctx() context: any, @Info() info: GraphQLResolveInfo, @Arg("domain", () => String!) domain: string): Promise<Website[]> {
        const website = await Website.findOne({ where: { domain } });
        website.pages = await WebsitePage.find({
            where: { website: { id: website.id } },
        });
        const template = await Template.findOne({
            where: { id: (<any>website).template },
            relations: templateRelations,
        });
        const newPages = this.getWebsitePages(template.pages, template.providerAssets);
        newPages.map((x) => {
            x.path = `/${uuidv4()}`;
            delete x.createdAt;
            delete x.updatedAt;
            return x;
        });
        website.pages = website.pages.concat(newPages);
        await Website.save(website);
        return await context.loader.loadEntity(Website, "website").where(`website.domain IN ('${domain}')`).info(info).loadMany();
    }

    @Authorized<Roles>([Roles.BASIC, Roles.TRUSTED, Roles.ADMIN, Roles.UNTRUSTED])
    @Mutation(() => String, { name: "uploadRobotsFile" })
    async uploadRobotsFile(@Arg("websiteId", () => Int, { validate: true }) websiteId: number, @Arg("content", () => String) content: string): Promise<string> {
        const website = await Website.findOne({ where: { id: websiteId } });
        if (!website || !website.domain) {
            throw new Error(`Website ${websiteId} does not exist`);
        }
        if (content.length === 0) {
            throw new Error("Robots content is empty");
        }
        const inMemoWriteStream = fs.createWriteStream("/robots.txt"); // using memfs package
        inMemoWriteStream.write(content);
        const inMemoReadStream = fs.createReadStream("/robots.txt"); // using memfs package
        return await this.s3FileHostingHelper.uploadFile(inMemoReadStream, website.bucketName, `robots.txt`, true, undefined, true);
    }

    @Authorized<Roles>([Roles.BASIC, Roles.TRUSTED, Roles.ADMIN])
    @Mutation(() => Website, { name: "updateWebsiteTemplate" })
    async updateWebsiteTemplate(
        @Ctx() context: any,
        @Info() info: GraphQLResolveInfo,
        @Arg("websiteId", () => Int) websiteId: number,
        @Arg("domain", () => String) domain: string,
        @Arg("templateId", () => Int!) templateId: number,
        @Arg("skipChecks", () => Boolean) skipChecks: boolean,
    ): Promise<Website> {
        const where: any = {};

        if (websiteId) {
            where.id = websiteId;
        } else if (domain) {
            where.domain = domain;
        }

        const website = await Website.findOne({ where, relations: ["template"] });
        const newTemplate = await Template.findOne({ where: { id: templateId } });

        if (!!skipChecks) {
            await Website.update({ id: website.id }, { template: { id: newTemplate.id } });
        } else {
            const isTemplateActive = !!newTemplate?.isActive;
            const isTemplateNewer = newTemplate?.createdAt > website?.template?.createdAt;
            const isWebsiteHaveNotInputTemplate = website?.template?.id !== newTemplate?.id;
            if (!!isTemplateActive && !!isTemplateNewer && !!isWebsiteHaveNotInputTemplate) {
                await Website.update({ id: website.id }, { template: { id: newTemplate.id } });
            } else {
                throw new Error(
                    `Update version failed due to checks isTemplateActive:${isTemplateActive} isTemplateNewer:${isTemplateNewer} isWebsiteHaveNotInputTemplate:${isWebsiteHaveNotInputTemplate}`,
                );
            }
        }
        await this.markPagesUnpublished([website]);
        return await context.loader.loadEntity(Website, "website").where(`website.id = (${website.id})`).info(info).loadOne();
    }

    @Authorized<Roles>([Roles.ADMIN])
    @Mutation(() => Boolean, { name: "updateWebsiteTemplateForAllSites" })
    @UseMiddleware(SlackNotification)
    async updateWebsiteTemplateForAllSites(
        @Ctx() ctx: any,
        @Arg("templateId", () => Int!, { nullable: false }) templateId: number,
        @Arg("skipChecks", () => Boolean, { nullable: true }) skipChecks?: boolean,
        @Arg("skipWebsites", () => [Int], { nullable: true }) skip_websites_ids?: number[],
    ): Promise<Boolean> {
        const websites = await Website.find();
        const db_data_source: DataSource = ctx.db_data_source; // for transaction
        const queryRunner = db_data_source.createQueryRunner();
        await queryRunner.startTransaction();
        try {
            const templateVersion = await Template.findOne({
                where: { id: templateId },
            }); // for slack and pusher
            const update_query: any = {};
            if (!!skip_websites_ids && !!skip_websites_ids.length) {
                update_query.id = Not(In(skip_websites_ids));
            }
            await Website.update(update_query, { template: { id: templateId } });
            await WebsitePage.update({}, { state: PageState.UNPUBLISHED });
            await queryRunner.commitTransaction();
            this.pusherAndSlack(websites, ctx.user.name, templateVersion.version);
            return true;
        } catch (err) {
            await queryRunner.rollbackTransaction();
            return false;
        } finally {
            await queryRunner.release();
        }
    }

    // @Authorized<Roles>([Roles.ADMIN])
    @Mutation(() => Boolean, { name: "testPusherResolver" })
    async testPusherResolver(@Ctx() ctx: any, @Info() info: GraphQLResolveInfo, @Arg("websiteId", () => Int!, { nullable: false }) websiteId: number): Promise<Boolean> {
        const websites = await Website.findOne({ where: { id: websiteId } }); // for slack and pusher
        this.pusherAndSlack([websites]);
        return true;
    }

    @Authorized<Roles>([Roles.BASIC, Roles.TRUSTED, Roles.ADMIN, Roles.UNTRUSTED])
    @Mutation(() => [WebsiteFilter], { name: "upsertWebsiteFilters" })
    async upsertWebsiteFilters(
        @Ctx() context: any,
        @Info() info: GraphQLResolveInfo,
        @Arg("websiteId", () => Int!) website_id: number,
        @Arg("filters", () => [WebsiteFilterInput], { validate: true }) filters: WebsiteFilterInput[],
    ): Promise<WebsiteFilter[]> {
        await Website.findOneByOrFail({ id: website_id });
        const websites_filters = filters.map((item) => Object.assign(new WebsiteFilter(), item, { website: { id: website_id } }));

        const [filters_to_update, filters_to_insert] = _.partition(websites_filters, (obj) => _.has(obj, "id"));

        const rows: WebsiteFilter[] = [];

        if (filters_to_update.length) {
            const update_rows: WebsiteFilter[] = filters_to_update.map((item) => Object.assign(new WebsiteFilter(), item));
            rows.push(...update_rows);
        }

        if (filters_to_insert.length) {
            rows.push(...filters_to_insert);
        }

        if (rows.length) {
            await WebsiteFilter.save(rows);
            await WebsitePage.update({ website: { id: website_id } }, { state: PageState.UNPUBLISHED });
        }

        return await context.loader.loadEntity(WebsiteFilter, "websites_filters").where(`websites_filters.website_id = ${website_id}`).info(info).loadMany();
    }

    @Authorized<Roles>([Roles.BASIC, Roles.TRUSTED, Roles.ADMIN, Roles.UNTRUSTED])
    @Mutation(() => Boolean, { name: "deleteWebsiteFilters" })
    async deleteWebsiteFilters(@Arg("websiteId", () => Int!) website_id: number, @Arg("filters", () => [Int!]!) filters: number[]): Promise<boolean> {
        const website_filters = await WebsiteFilter.find({ where: { website: { id: website_id } } });
        const is_filters_belong_to_website = _.every(filters, (number) => _.some(website_filters, { id: number }));
        if (is_filters_belong_to_website) {
            await WebsiteFilter.createQueryBuilder().delete().where("id IN (:...ids)", { ids: filters }).execute();

            await WebsitePage.update({ website: { id: website_id } }, { state: PageState.UNPUBLISHED });

            return true;
        }
        throw new Error("Filters not belong to website");
    }

    @Mutation(() => Boolean, { name: "invalidateWebsiteCache" })
    async invalidateWebsiteCache(@Arg("websiteId", () => Int!) websiteId: number): Promise<boolean> {
        const website = await Website.findOne({ where: { id: websiteId } });
        if (!website) {
            throw new Error("Website Not Exists");
        }
        if (!website.distributionId) {
            throw new Error("Unable to clear the site cache, missing data");
        }
        await this.cloudFrontHelper.invalidateFiles(website.distributionId, [`/*`]);
        return true;
    }

    @FieldResolver(() => String)
    async robotsFile(@Ctx() ctx: Context, @Root() website: Website): Promise<string> {
        const { Body } = await this.s3FileHostingHelper.getObject(website.bucketName, "robots.txt");
        return await FileUtils.streamToString(Body as Readable);
    }

    @FieldResolver(() => [String])
    async websiteLabels(@Ctx() context: Context, @Info() info: GraphQLResolveInfo, @Root() website: Website): Promise<string[]> {
        const raw_query = `SELECT ARRAY_AGG(DISTINCT element) AS labels
            FROM (
                SELECT UNNEST(labels) AS element
                FROM websites_pages
                 where "websiteId" = ${website.id}
            ) AS subquery;`;

        const db_data_source: DataSource = context.db_data_source;
        const [{ labels }] = await db_data_source.createQueryRunner().query(raw_query);
        return labels || [];
    }

    @FieldResolver(() => [String])
    async segmentsWebsiteLabels(@Ctx() context: Context, @Info() info: GraphQLResolveInfo, @Root() website: Website): Promise<string[]> {
        const raw_query = `SELECT ARRAY_AGG(DISTINCT element) AS labels
            FROM (
                SELECT UNNEST(labels) AS element
                FROM segments
                 where "websiteId" = ${website.id}
            ) AS subquery;`;

        const db_data_source: DataSource = context.db_data_source;
        const [{ labels }] = await db_data_source.createQueryRunner().query(raw_query);
        return labels || [];
    }

    @FieldResolver(() => [String])
    async providersWebsiteLabels(@Ctx() context: Context, @Info() info: GraphQLResolveInfo, @Root() website: Website): Promise<string[]> {
        const raw_query = `SELECT ARRAY_AGG(DISTINCT element) AS labels
            FROM (
                SELECT UNNEST(labels) AS element
                FROM providers
                 where "websiteId" = ${website.id}
            ) AS subquery;`;

        const db_data_source: DataSource = context.db_data_source;
        const [{ labels }] = await db_data_source.createQueryRunner().query(raw_query);
        return labels || [];
    }

    @FieldResolver(() => String)
    async publishAverage(@Ctx() ctx: Context, @Root() website: Website): Promise<string> {
        const [{ publish_avg }] = await AuditTrail.query(`
            SELECT avg(finishPublishWebsite.action_time - startPublishWebsite.action_time) as publish_avg from audit_trail startPublishWebsite
            left join
                (SELECT action_time, action, variables->>'jobId' as end_job_id from audit_trail where domain = '${website.domain}' and action like 'finishPublishWebsite') as finishPublishWebsite
                on finishPublishWebsite.end_job_id = variables->>'jobId'
            where startPublishWebsite.domain = '${website.domain}' and startPublishWebsite.action like 'startPublishWebsite'`);
        if (!publish_avg) {
            return "";
        }
        let dateString = "";
        for (const [key, value] of Object.entries(publish_avg)) {
            dateString += ` ${value} ${key}`;
        }
        return dateString.replace(" ", "");
    }

    @FieldResolver(() => Boolean)
    async isCredible(@Ctx() ctx: Context, @Root() website: Website): Promise<boolean> {
        const provider = await Provider.findOne({
            where: {
                website: { id: website.id },
                credible_external_id: Not(IsNull()),
            },
        });
        return !!provider;
    }

    @FieldResolver(() => PublishState)
    async publishStatus(@Ctx() ctx: any, @Root() website: Website): Promise<PublishState> {
        if (ctx?.websites_publish_state && ctx?.websites_publish_state[website.id]) {
            return ctx?.websites_publish_state[website.id];
        }
        return undefined;
    }

    @FieldResolver(() => RankingState)
    async rankingStatus(@Ctx() ctx: any, @Root() website: Website): Promise<RankingState> {
        if (ctx?.websites_ranking_upload_state && ctx?.websites_ranking_upload_state[website.id]) {
            return ctx?.websites_ranking_upload_state[website.id];
        }
        return undefined;
    }

    private getWebsitePages(
        pages: TemplatePage[],
        providerAssets: TemplateAsset[],
        default_global_vertical_id?: number,
        default_provider_vertical_id?: number,
        websiteStrategy?: WebsiteStrategy,
    ) {
        const websitePages: WebsitePage[] = [];
        for (const templatePage of pages) {
            const websitePage = new WebsitePage();
            const cloneTemplatePage = _.cloneDeep(templatePage);
            WebsiteUtils.removeId(cloneTemplatePage);
            Object.assign(websitePage, cloneTemplatePage);
            websitePage.name = cloneTemplatePage.title;
            websitePage.assets = this.getPageAssets(templatePage);
            websitePage.components = this.getWebsiteComponents(templatePage, providerAssets);
            if (!!websiteStrategy && websiteStrategy === WebsiteStrategy.SEGMENTS) {
                websitePage.isLayout = true;
            }
            if (!!default_global_vertical_id) {
                const default_global_vertical = new WebsiteGlobalVertical();
                default_global_vertical.id = default_global_vertical_id;
                websitePage.globalVertical = default_global_vertical;
            }
            if (!!default_provider_vertical_id) {
                const default_provider_vertical = new WebsiteVertical();
                default_provider_vertical.id = default_provider_vertical_id;
                websitePage.vertical = default_provider_vertical;
            }
            websitePages.push(websitePage);
        }
        return websitePages;
    }

    private getWebsiteComponents(page: TemplatePage, providerAssets: TemplateAsset[]): WebsitePageComponent[] {
        const websitePagesComponents: WebsitePageComponent[] = [];
        for (const templatePageComponent of page.templatePageComponents) {
            const websitePageComponent = new WebsitePageComponent();
            const cloneTemplatePageComponent = _.cloneDeep(templatePageComponent.component);
            WebsiteUtils.removeId(cloneTemplatePageComponent);
            Object.assign(websitePageComponent, cloneTemplatePageComponent);
            websitePageComponent.templateComponent = templatePageComponent.component;
            websitePageComponent.index = templatePageComponent.index;
            websitePageComponent.assets = this.getComponentAssets(templatePageComponent, providerAssets);
            websitePagesComponents.push(websitePageComponent);
        }
        return websitePagesComponents;
    }

    private getPageAssets(templatePage: TemplatePage) {
        const pageAssets: PageAsset[] = [];
        const templatePageLevelAssets = templatePage.assets.filter((asset) => asset.assetLevel === AssetLevel.PAGE);
        for (const pageAsset of templatePageLevelAssets) {
            const clonedPageAsset = _.cloneDeep(pageAsset);
            WebsiteUtils.removeId(clonedPageAsset);
            pageAssets.push(Object.assign(new PageAsset(), clonedPageAsset));
        }
        return pageAssets;
    }

    private getComponentAssets(templatePageComponent: TemplatePageComponent, providerAssets: TemplateAsset[]) {
        const componentAssets: ComponentAsset[] = [];
        const templateComponentAssets = _.pullAllBy(templatePageComponent.component.assets, providerAssets, "id");
        const templateComponentLevelAssets = templateComponentAssets.filter((asset) => asset.assetLevel === AssetLevel.COMPONENT);
        for (const componentAsset of templateComponentLevelAssets) {
            const clonedPageAsset = _.cloneDeep(componentAsset);
            WebsiteUtils.removeId(clonedPageAsset);
            componentAssets.push(Object.assign(new ComponentAsset(), clonedPageAsset));
        }
        return componentAssets;
    }

    private get_website_global_vertical_assets(template: Template, default_global_website_vertical: WebsiteGlobalVertical): GlobalVerticalAsset[] {
        const website_global_vertical_assets: GlobalVerticalAsset[] = [];
        for (const template_global_asset of template.globalAssets) {
            const global_vertical_asset = new GlobalVerticalAsset();
            const cloned_template_global_asset = _.cloneDeep(template_global_asset);
            WebsiteUtils.removeId(cloned_template_global_asset);
            Object.assign(global_vertical_asset, cloned_template_global_asset);
            global_vertical_asset.vertical = default_global_website_vertical;
            website_global_vertical_assets.push(global_vertical_asset);
        }
        return website_global_vertical_assets;
    }

    private async markPagesUnpublished(websites: Website[]): Promise<void> {
        const ids: any[] = websites.map((website) => website.id);
        await WebsitePage.update({ website: In(ids) }, { state: PageState.UNPUBLISHED });
    }

    private async updateVisitorsTable(domain: string, visitorsCounter: UpdateWebsiteVisitorsCounterInput) {
        const dynamo_helper = new DynamoHelper();
        const getNextMonthsEpochTimeInSeconds = (numOfMonths: number = 1) => {
            const d = new Date();
            const currentMonth = d.getMonth();
            const nextMonth = currentMonth + numOfMonths;
            const nextMonthDate = new Date(d.getFullYear(), nextMonth, d.getDate(), d.getHours(), d.getMinutes(), d.getSeconds());
            const nextMonthEpochTimeInSeconds = nextMonthDate.getTime() / 1000;
            return nextMonthEpochTimeInSeconds.toString();
        };

        const getNextWeekEpochTimeInSeconds = () => {
            const d = new Date();
            const nextWeek = new Date(d.getTime() + 7 * 24 * 60 * 60 * 1000);
            const nextWeekEpochTimeInSeconds = nextWeek.getTime() / 1000;
            return nextWeekEpochTimeInSeconds.toString();
        };

        domain = domain.replace(/\./g, "").replace(/\-/g, "");

        const item: any = {
            key: { S: domain },
            initialCounterValue: {
                N: visitorsCounter.initialCounterValue.toString(),
            },
            renewPeriod: { S: visitorsCounter.renewPeriod },
        };

        switch (item.renewPeriod.S) {
            case "WEEK":
                item.expiration = { N: getNextWeekEpochTimeInSeconds() };
                item.visitors = { N: item.initialCounterValue.N };
                break;
            case "MONTH":
                item.expiration = { N: getNextMonthsEpochTimeInSeconds() };
                item.visitors = { N: item.initialCounterValue.N };
                break;
            case "NEVER":
                item.expiration = { N: getNextMonthsEpochTimeInSeconds(400) };
            case "DELETE":
            default:
                break;
        }

        const params = {
            TableName: process.env.VISITORS_DYNAMO_TABLE_NAME,
            Item: item,
        };
        try {
            await dynamo_helper.putItem(params);
        } catch (error) {
            throw new Error(`Unable to update dynamo table ${process.env.VISITORS_DYNAMO_TABLE_NAME} + ${error}`);
        }
    }

    private pusherAndSlack(websites_to_update: Website[], userName: string = undefined, templateVersion: string = undefined): void {
        const lambdaClient = new LambdaHelper(); // For pusher
        for (const website of websites_to_update) {
            let stage = process.env.NODE_ENV;
            if (stage === "integration") {
                stage = "integ";
            }
            lambdaClient.invoke_lambda_pusher(`${website.id.toString()}_${process.env.NODE_ENV}`, "updated template");
        }
        if (!!userName && !!templateVersion && process.env.NODE_ENV === "prod") {
            const listOfChannels = ["creator-team", "seo-team", "ppc-team", "template-version-sync"];
            const subject = "Updated template";
            for (const channel of listOfChannels) {
                this.snsClient.publish(process.env.TOPIC_SLACK_BOT, `${userName} just deployed ${templateVersion} template to production`, undefined, false, channel, subject);
            }
        }
    }

    private async createDefaultSegment(website: Website, defaultProviderVertical: WebsiteVertical, defaultGlobalWebsiteVertical: WebsiteGlobalVertical) {
        const layout = website.pages.find((x) => x.path.replace("/", "").replace(".html", "") === "compare");
        const defaultSegment = new Segment();
        const segmentUniqueId = `${website.domain}_Default`;
        defaultSegment.name = "Default";
        defaultSegment.isDefault = true;
        defaultSegment.uniqueId = segmentUniqueId;
        defaultSegment.layout = layout;
        defaultSegment.website = website;
        defaultSegment.status = SegmentStatus.ONLINE;
        defaultSegment.providerFixedPositions = layout?.providerFixedPositions;
        defaultSegment.vertical = defaultProviderVertical;
        defaultSegment.globalVertical = defaultGlobalWebsiteVertical;
        defaultSegment.title = layout?.title;
        defaultSegment.algo = layout?.algo;
        defaultSegment.canonical = layout?.canonical;
        defaultSegment.labels = layout?.labels;
        defaultSegment.metaDescription = layout?.metaDescription;
        defaultSegment.tags = layout?.tags;

        return defaultSegment;
    }

    private async set_websites_publish_state(context: any, ids: number[]) {
        try {
            const { Responses } = await this.dynamo_helper.batchGetItem(process.env.DYNAMO_PUBLISH_STATE, ids, "website", "N");
            const websites_publish_state: any = [];
            for (const item of Responses[process.env.DYNAMO_PUBLISH_STATE]) {
                const result: any = {};
                for (const key in item) {
                    const valueObject = item[key];
                    if ("N" in valueObject) {
                        result[key] = Number(valueObject.N);
                    } else if ("S" in valueObject) {
                        result[key] = valueObject.S;
                    } else if ("BOOL" in valueObject) {
                        result[key] = valueObject.BOOL;
                    }
                }
                websites_publish_state.push(result);
            }
            context.websites_publish_state = _.keyBy(websites_publish_state, "website");
        } catch (e) {
            context.websites_publish_state = {};
            console.log(e);
        }
    }

    private async set_websites_ranking_upload_state(context: any, ids: number[]) {
        try {
            const { Responses } = await this.dynamo_helper.batchGetItem(process.env.DYNAMO_RANKING_STATE, ids, "website", "N");
            const websites_ranking_upload_state: any = [];
            for (const item of Responses[process.env.DYNAMO_RANKING_STATE]) {
                const result: any = {};
                for (const key in item) {
                    const valueObject = item[key];
                    if ("N" in valueObject) {
                        result[key] = Number(valueObject.N);
                    } else if ("S" in valueObject) {
                        result[key] = valueObject.S;
                    } else if ("BOOL" in valueObject) {
                        result[key] = valueObject.BOOL;
                    }
                }
                websites_ranking_upload_state.push(result);
            }
            context.websites_ranking_upload_state = _.keyBy(websites_ranking_upload_state, "website");
        } catch (e) {
            context.websites_ranking_upload_state = {};
            console.log(e);
        }
    }

    @FieldResolver(() => Boolean)
    async isTemplateLive(@Ctx() context: any, @Root() website: Website): Promise<boolean> {
        const website_with_template = await Website.findOneOrFail({ where: { id: website.id }, relations: ["template"] });
        return !!context?.live_versions_map && !!context?.live_versions_map[website_with_template.template.version];
    }
}

File: /src/resolvers/publishSchedulingResolver.ts 
import { PublishScheduling, PublishSchedulingStatus, Roles, Website } from "@moonshot-marketing/creator-entities";
import { GraphQLResolveInfo } from "graphql";
import { Arg, Authorized, Ctx, Info, Int, Mutation, Query, Resolver } from "type-graphql";
import { DataSource } from "typeorm";
import { v4 as uuidv4 } from "uuid";
import { CreatePublishSchedulingInput } from "../inputs/createPublishSchedulingInput";
import { EventBridgeUtil } from "../utils/eventBridgeUtil";

@Resolver(() => PublishScheduling)
export class PublishSchedulingResolver {

    @Authorized<Roles>([Roles.BASIC, Roles.TRUSTED, Roles.ADMIN])
    @Query(() => [PublishScheduling], { name: "publishScheduling" })
    async read(
        @Ctx() context: any,
        @Info() info: GraphQLResolveInfo,
        @Arg("ids", () => [Int], { nullable: true }) ids?: [number],
        @Arg("websiteId", () => Int, { nullable: true }) websiteId?: number
    ): Promise<PublishScheduling[] | PublishScheduling> {

        const whereExpressions: string[] = [];
        if (!!ids && ids.length) {
            whereExpressions.push(`publishScheduling.id IN (${ids})`);
        }
        if (!!websiteId) {
            whereExpressions.push(`publishScheduling.websiteId = ${websiteId}`);
        }

        const where = whereExpressions.join(" AND ");
        return await context.loader
            .loadEntity(PublishScheduling, "publishScheduling")
            .where(where)
            .info(info)
            .loadMany();
    }

    @Authorized<Roles>([Roles.BASIC, Roles.TRUSTED, Roles.ADMIN])
    @Mutation(() => PublishScheduling, { name: "updatePublishScheduling" })
    async update(
        @Ctx() context: any,
        @Info() info: GraphQLResolveInfo,
        @Arg("id", () => Int, { nullable: false }) id: number,
        @Arg("status", () => PublishSchedulingStatus, { nullable: false }) status: PublishSchedulingStatus
    ): Promise<PublishScheduling | PublishScheduling[]> {

        const eventBridgeUtil = new EventBridgeUtil();
        const publishSchedulingNeedCancel: PublishScheduling = await PublishScheduling.findOne({ where: { id } });
        if (!publishSchedulingNeedCancel) throw new Error("relevant PublishScheduling not found");

        await PublishScheduling.update({ id: publishSchedulingNeedCancel.id }, { status });
        if (status === PublishSchedulingStatus.WAITING) {
            await eventBridgeUtil.enableRule(publishSchedulingNeedCancel.ruleName);
        } else {
            await eventBridgeUtil.disableRule(publishSchedulingNeedCancel.ruleName);
        }

        return await context.loader.loadEntity(PublishScheduling, "publish_scheduling").where(`"publish_scheduling"."id" = ${publishSchedulingNeedCancel.id}`).info(info).loadOne();
    }

    @Authorized<Roles>([Roles.BASIC, Roles.TRUSTED, Roles.ADMIN])
    @Mutation(() => PublishScheduling, { name: "createPublishScheduling" })
    async create(
        @Ctx() ctx: any,
        @Info() info: GraphQLResolveInfo,
        @Arg("data", () => CreatePublishSchedulingInput, { validate: true }) input: CreatePublishSchedulingInput
    ): Promise<PublishScheduling | PublishScheduling[]> {

        const eventBridgeUtil = new EventBridgeUtil();
        const website: Website = await Website.findOne({ where: { id: input.websiteId } });

        // validations
        if (!website) throw new Error("Website not found");

        const publishScheduling = new PublishScheduling();
        Object.assign(publishScheduling, {
            status: PublishSchedulingStatus.WAITING,
            ruleName: `Creator-PublishScheduling-${uuidv4()}`,
            publishedAt: input.publishAt,
            website
        });
        const db_data_source: DataSource = ctx.db_data_source;
        const queryRunner = db_data_source.createQueryRunner();

        await queryRunner.startTransaction();

        try {
            const result = await queryRunner.manager.save(publishScheduling);
            const publishLambdaInputData = this.getPublishLambdaInputData(input, website, result.id, ctx);
            await eventBridgeUtil.createRule(publishScheduling.ruleName, process.env.PUBLISH_LAMBDA_ARN, input.publishAt, publishLambdaInputData);
            await queryRunner.commitTransaction();
            await queryRunner.release();
        } catch (err) {
            await queryRunner.rollbackTransaction();
            await queryRunner.release();
            throw new err;
        }

        return await ctx.loader.loadEntity(PublishScheduling, "publish_scheduling").where(`"publish_scheduling"."id" = ${publishScheduling.id}`).info(info).loadOne();
    }

    private getPublishLambdaInputData(input: CreatePublishSchedulingInput, website: Website, newRowId: number, ctx: any) {
        return {
            headers: { "Authorization": input.token },
            body: JSON.stringify({
                template: { name: input.templateName, version: input.templateVersion },
                websiteId: website.id,
                userName: ctx.user.email,
                slackChannel: website.slackChannel,
                scheduleId: newRowId,
                domain: website.domain,
                distributionId: website.distributionId,
            })
        };
    }
}

File: /src/resolvers/mediaGalleryResolver.ts 
import { CloudFrontHelper, S3FileHostingHelper } from "@moonshot-marketing/creator-cloud";
import { MediaGalleryAsset, Roles, Website, WebsiteUtils } from "@moonshot-marketing/creator-entities";
import { Context } from "@moonshot-marketing/creator-server";
import { FileUtils } from "@moonshot-marketing/creator-utils";
import { GraphQLResolveInfo } from "graphql";
import * as _ from "lodash";
import { Arg, Args, Authorized, Ctx, Directive, FieldResolver, Info, Int, Mutation, Query, Resolver, Root } from "type-graphql";
import { In } from "typeorm";
import { PaginationArgs } from "../argsTypes/PaginationArgs";
import { MediaGalleryAssetInput } from "../inputs/mediaGalleryAssetInput";
import { UpdateMediaGalleryAssetInput } from "../inputs/updateMediaGalleryAssetInput";
import { MediaGalleryResponse } from "../responseTypes/MediaGalleryResponse";
import { MediaGalleryUtil } from "../utils/mediaGalleryUtils";
const sharp = require("sharp");
import * as dayjs from "dayjs";

const IMAGES_DIRECTORY = "assets";

@Resolver(() => MediaGalleryAsset)
export class MediaGalleryResolver {
    private readonly s3FileHostingHelper = new S3FileHostingHelper();
    private readonly cloudFrontHelper: CloudFrontHelper = new CloudFrontHelper();

    @Authorized<Roles>([Roles.BASIC, Roles.TRUSTED, Roles.ADMIN, Roles.UNTRUSTED])
    @Query(() => MediaGalleryResponse, { name: "mediaGalleryAssets" })
    async read(
        @Ctx() context: any,
        @Info() info: GraphQLResolveInfo,
        @Args() { offset, take }: PaginationArgs,
        @Arg("websiteId", () => Int) websiteId: number,
        @Arg("path", () => String) path: string,
        @Arg("ids", () => [Int]) ids?: number[],
    ): Promise<MediaGalleryResponse> {
        const whereExpressions: string[] = [];
        if (!!ids && ids.length) {
            whereExpressions.push(`mediaGalleryAsset.id IN (${ids})`);
        }
        if (websiteId) {
            whereExpressions.push(`"mediaGalleryAsset"."websiteId" = ${websiteId}`);
        }
        if (path) {
            whereExpressions.push(`"mediaGalleryAsset"."path" = '${path}'`);
        }
        const where = whereExpressions.join(" AND ");
        const [records, totalCount] = await context.loader
            .loadEntity(MediaGalleryAsset, "mediaGalleryAsset")
            .where(where)
            .info(info, "records")
            .paginate({ limit: take, offset: offset })
            .loadPaginated();
        return { totalCount, records };
    }

    // @Authorized<Roles>([Roles.BASIC, Roles.TRUSTED, Roles.ADMIN, Roles.UNTRUSTED])
    @Mutation(() => [MediaGalleryAsset], { name: "uploadMediaGalleryAssets" })
    async create(
        @Ctx() context: any,
        @Info() info: GraphQLResolveInfo,
        @Arg("websiteId", () => Int!) websiteId: number,
        @Arg("assets", () => [MediaGalleryAssetInput!]!) mediaGalleryAssetInputs: MediaGalleryAssetInput[],
    ): Promise<MediaGalleryAsset[]> {
        const website = await Website.findOne({ where: { id: websiteId } });
        if (!website) {
            throw new Error(`website ${websiteId} does not exist`);
        }

        const assets: MediaGalleryAsset[] = [];
        const filesPathsToInvalidate: string[] = [];
        // Validate all inputs are images
        for (const input of mediaGalleryAssetInputs) {
            const image = await input.image;
            input.filename = input.filename.replace(/ /g, "_");
            if (image.mimetype.search("image/") === -1) throw new Error(`File type is not an image`);
        }

        // parallel upload images to S3

        const promises = mediaGalleryAssetInputs.map(async (input: MediaGalleryAssetInput) => {
            const image = await FileUtils.readFileStreamToBuffer(await input.image);
            const metadata = await sharp(image).metadata();
            const date = dayjs().format("YYYY-MM-DD-HH-mm-ss");
            const mediaGalleryAsset = new MediaGalleryAsset();
            const file_path = `${IMAGES_DIRECTORY}/${date}/${input.filename}`;
            filesPathsToInvalidate.push(`/${file_path}`);

            const path = await this.s3FileHostingHelper.uploadFile(image, website.bucketName, file_path, true, undefined);
            const moon_box_key = `${website.domain}/media_gallery_assets/${date}/${input.filename}`;
            await this.s3FileHostingHelper.upload(process.env.MOONBOX_BUCKET, moon_box_key, image, false);
            await this.s3FileHostingHelper.tag_object(process.env.MOONBOX_BUCKET, moon_box_key, [{ Key: "USER_UPLOAD", Value: "TRUE" }]);
            const params = {
                path: path,
                metadata: metadata,
                altText: input.altText,
                website: { id: websiteId },
                filename: input.filename,
            };
            Object.assign(mediaGalleryAsset, params);
            assets.push(mediaGalleryAsset);
        });

        await Promise.all(promises);

        this.cloudFrontHelper.invalidateFiles(website.distributionId, filesPathsToInvalidate).catch(console.error);

        await MediaGalleryAsset.save(assets);
        const ids = assets.map((asset: MediaGalleryAsset) => asset.id);
        const where = !!ids && ids.length ? `mediaGalleryAsset.id IN (${ids})` : "";
        return await context.loader.loadEntity(MediaGalleryAsset, "mediaGalleryAsset").info(info).where(where).loadMany();
    }

    @Authorized<Roles>([Roles.BASIC, Roles.TRUSTED, Roles.ADMIN, Roles.UNTRUSTED])
    @Mutation(() => [MediaGalleryAsset], { name: "updateMediaGalleryAssets" })
    async update(@Arg("input", () => [UpdateMediaGalleryAssetInput!]!) input: UpdateMediaGalleryAssetInput[]): Promise<MediaGalleryAsset[]> {
        const paths: string[] = input.map((asset) => asset.path);
        const assets = await MediaGalleryAsset.find({ where: { path: In(paths) } });
        const pathToAssetDictionary: any = {};
        for (const asset of assets) {
            pathToAssetDictionary[asset.path] = asset;
        }
        for (const asset of input) {
            const assetToUpdate = pathToAssetDictionary[asset.path];
            if (!assetToUpdate) {
                throw new Error(`asset ${asset.path} not found`);
            }
            delete asset.path;
            Object.assign(assetToUpdate, asset);
        }
        return await MediaGalleryAsset.save(assets);
    }

    @Authorized<Roles>([Roles.BASIC, Roles.TRUSTED, Roles.ADMIN, Roles.UNTRUSTED])
    @Mutation(() => [MediaGalleryAsset], { name: "deleteMediaGalleryAssets" })
    async delete(@Arg("paths", () => [String!]!) paths: string[], @Arg("websiteId", () => Int!) websiteId: number): Promise<MediaGalleryAsset[]> {
        const website = await Website.findOne({ where: { id: websiteId } });

        const assetsToDelete = await MediaGalleryAsset.find({ where: { path: In(paths) } });
        const s3ObjectsToDelete = assetsToDelete.map((asset) => `${IMAGES_DIRECTORY}/${asset.filename}`);
        await this.s3FileHostingHelper.removeObjects(website.bucketName, s3ObjectsToDelete);
        return await MediaGalleryAsset.remove(assetsToDelete);
    }

    @FieldResolver(() => String)
    @Directive('@deprecated(reason: "Use resizer")')
    async resizerPath(@Ctx() ctx: Context, @Root() asset: MediaGalleryAsset): Promise<String> {
        return await MediaGalleryUtil.getImageHandlerUrl(asset.path as string);
    }

    @FieldResolver(() => String)
    async resizer(@Ctx() ctx: Context, @Root() asset: MediaGalleryAsset): Promise<String> {
        return await MediaGalleryUtil.resizer(asset.path as string);
    }

    @Authorized<Roles>([Roles.BASIC, Roles.TRUSTED, Roles.ADMIN, Roles.UNTRUSTED])
    @Mutation(() => Boolean, { name: "cloneMediaGalleryAssets" })
    async clone_media_assets(@Arg("sourceWebsiteId", () => Int!) sourceId: number, @Arg("destWebsiteId", () => Int!) destId: number): Promise<boolean> {
        this.clone_files(sourceId, destId);
        return true;
    }

    private async clone_files(sourceId: number, destId: number) {
        const source_website = await Website.findOneOrFail({ where: { id: sourceId }, relations: ["mediaGalleryAssets"] });
        const dest_website = await Website.findOneOrFail({ where: { id: destId } });

        const new_media_assets = _.cloneDeep(source_website.mediaGalleryAssets);
        WebsiteUtils.removeIdFromArr(new_media_assets);
        let website_bucket_name = source_website.bucketName;
        let new_website_bucket_name = dest_website.bucketName;

        for (const media_asset of new_media_assets) {
            const key = `assets/${media_asset.filename}`;
            const file = await this.s3FileHostingHelper.getObject(website_bucket_name, key);
            const path = await this.s3FileHostingHelper.uploadFile(file.Body, new_website_bucket_name, key, true, undefined, true);
            media_asset.path = path as string;
            media_asset.website = dest_website;
        }
        dest_website.mediaGalleryAssets = await MediaGalleryAsset.save(new_media_assets);
    }
}

File: /src/resolvers/sitemapResolver.ts 
import { DynamoHelper, S3FileHostingHelper } from "@moonshot-marketing/creator-cloud";
import { PageState, PageStatus, PageType, Roles, Website, WebsitePage, WebsiteStrategy } from "@moonshot-marketing/creator-entities";
import * as arrayToTree from "array-to-tree";
import { GraphQLResolveInfo } from "graphql";
import * as _ from "lodash";
import { Arg, Authorized, Ctx, Info, Int, Mutation, Query, Resolver } from "type-graphql";
import { In } from "typeorm";
import { UpdateSitemapInput } from "../inputs/UpdateSitemapInput";

@Resolver(() => WebsitePage)
export class SitemapResolver {
    private readonly dynamo_helper: DynamoHelper;
    private readonly s3_helper: S3FileHostingHelper;

    constructor() {
        this.dynamo_helper = new DynamoHelper();
        this.s3_helper = new S3FileHostingHelper();
    }

    @Authorized<Roles>([Roles.BASIC, Roles.TRUSTED, Roles.ADMIN, Roles.UNTRUSTED])
    @Query(() => [WebsitePage], { name: "sitemap" })
    async read(@Ctx() context: any, @Info() info: GraphQLResolveInfo, @Arg("websiteId", () => Int!, { nullable: false }) websiteId: number): Promise<WebsitePage[] | WebsitePage> {
        const website = await Website.findOneOrFail({ where: { id: websiteId } });

        const whereExpressions: string[] = [];
        whereExpressions.push(`"websitePage"."websiteId" = ${websiteId}`);
        whereExpressions.push(`"websitePage"."type" != '${PageType.TEST}'`);
        whereExpressions.push(`"websitePage"."type" != '${PageType.TEST_ON_ASSET}'`);
        whereExpressions.push(`"websitePage"."type" != '${PageType.TEST_ON_FUNNEL}'`);
        whereExpressions.push(`"websitePage"."type" != '${PageType.TEST_ON_PAGE}'`);
        whereExpressions.push(`"websitePage"."status" != '${PageStatus.MERGED}'`);

        if (website.websiteStrategy === WebsiteStrategy.SEGMENTS) {
            whereExpressions.push(`"websitePage"."is_layout" = true`);
        }
        const where = whereExpressions.join(" AND ");

        return await context.loader.loadEntity(WebsitePage, "websitePage").info(info).where(where).loadMany();
    }

    @Authorized<Roles>([Roles.BASIC, Roles.TRUSTED, Roles.ADMIN, Roles.UNTRUSTED])
    @Mutation(() => [WebsitePage], { name: "sitemap" })
    async update(
        @Ctx() context: any,
        @Info() info: GraphQLResolveInfo,
        @Arg("updateSitemapInput", () => [UpdateSitemapInput], { validate: true }) updateSitemapInput: UpdateSitemapInput[],
    ) {
        // Get The Input Pages as tree, with parent as root
        const pagesAsTree = arrayToTree(updateSitemapInput, { parentProperty: "parentId" });

        // Get All Website Pages as a Dictionary For setting parents
        const allPagesIds = updateSitemapInput.map((pageInput) => pageInput.id);
        const pages = await WebsitePage.find({ where: { id: In(allPagesIds) }, relations: ["website"] });
        const allPagesMappedById = _.keyBy(pages, "id");
        const slugs_to_remove: string[] = [];
        for (const input of updateSitemapInput) {
            const page = allPagesMappedById[input.id];
            if (page.path.replace(".html", "") !== input.path.replace(".html", "")) {
                slugs_to_remove.push(`${page.website.bucketName}${page.path}`);
            }
        }

        // Flat the input pages tree again, now in order (parent, then children), and generate website pages

        const orderedInputPageArray = await this.flatTreeToArrayByChildren(pagesAsTree);
        const orderedWebsitePageArray = this.getPageArrayFromInputArray(orderedInputPageArray, allPagesMappedById);

        // Save this array in order
        const updatedPages = await WebsitePage.save(orderedWebsitePageArray);
        if (!!slugs_to_remove.length) {
            for (const slug of slugs_to_remove) {
                const put_item = { TableName: process.env.DYNAMO_S3_PAGES_TO_REMOVE_TABLE, Item: { slug: { S: slug } } };
                await this.dynamo_helper.putItem(put_item);
            }
        }
        const updatedPagesIds = updatedPages.map((page) => page.id);
        return await context.loader.loadEntity(WebsitePage, "websitePage").where(`websitePage.id IN (${updatedPagesIds})`).info(info).loadMany();
    }

    /**
     *  Flattens a tree type array by its children property recursively
     * @param array (exmaple : [
     * @private
     */
    private async flatTreeToArrayByChildren(array: any) {
        let result: any = [];
        for (const pageInput of array) {
            result.push(pageInput);
            if (Array.isArray(pageInput.children)) {
                result = result.concat(await this.flatTreeToArrayByChildren(pageInput.children));
            }
        }
        return result;
    }

    /**
     * Constructs a website page object from an input page
     * @param inputPagesArray
     * @param pages
     * @private
     */
    private getPageArrayFromInputArray(inputPagesArray: UpdateSitemapInput[], pages: _.Dictionary<WebsitePage>): WebsitePage[] {
        return inputPagesArray.map((inputPage: UpdateSitemapInput) => {
            const parentPage = pages[inputPage.parentId];
            const websitePage = new WebsitePage();
            Object.assign(websitePage, {
                id: inputPage.id,
                path: inputPage.path,
            });
            if (!!parentPage) websitePage.parent = parentPage;
            else websitePage.parent = null; // do not change to undefined! even if linter says. it has to be Postgres null
            websitePage.state = PageState.UNPUBLISHED;
            return websitePage;
        });
    }
}

File: /src/resolvers/ProductResolver.ts 
import {
    Product,
    ProductProvider,
    Roles,
    TemplateAsset,
    SectionUtils,
    ProductAsset,
    Website, Affiliate
} from "@moonshot-marketing/creator-entities";
import { Context, DatabaseUtils } from "@moonshot-marketing/creator-server";
import { GraphQLResolveInfo } from "graphql";
import * as _ from "lodash";
import { Arg, Authorized, Ctx, Info, Int, Mutation, Query, Resolver } from "type-graphql";
import { In } from "typeorm";
import { MultipleProductsEditInput } from "../inputs/MultipleProductsEditInput";
import { UpsertProductsInput } from "../inputs/UpsertProductsInput";
import { ProductRankingFileUtils } from "../utils/ProductRankingFileUtils";
import { FileUpload, GraphQLUpload } from "graphql-upload";
import { parseStream } from "fast-csv";

@Resolver(() => Product)
export class ProductResolver {

    @Authorized<Roles>([Roles.BASIC, Roles.TRUSTED, Roles.ADMIN, Roles.UNTRUSTED])
    @Query(() => [Product], { name: "products" })
    async products(
        @Ctx() context: any,
        @Info() info: GraphQLResolveInfo,
        @Arg("ids", () => [Int], { nullable: true }) ids: number[],
        @Arg("website_id", () => [Int], { nullable: true }) website_id: number
    ) {
        const where = !!ids ? `product.id IN (${ids})` : !!website_id ? `product."websiteId" = ${website_id}` : "";
        return await context.loader.loadEntity(Product, "product").where(where).info(info).loadMany();
    }

    @Authorized<Roles>([Roles.BASIC, Roles.TRUSTED, Roles.ADMIN, Roles.UNTRUSTED])
    @Mutation(() => Product, { name: "upsertProduct" })
    async upsertProduct(
        @Ctx() context: any,
        @Info() info: GraphQLResolveInfo,
        @Arg("upsertProductInput", () => UpsertProductsInput, { validate: true }) upsert_product_input: UpsertProductsInput
    ) {
        const product = new Product();
        Object.assign(product, _.cloneDeep(upsert_product_input));
        delete product.assets;
        delete product.providers;
        await Product.save(product);

        const { assets } = await Product.findOne({ where: { id: product.id }, relations: ["assets"] });

        if (!!upsert_product_input.assets?.length) {
            const template_assets_ids: number[] = _.map(upsert_product_input.assets, "templateAssetId");
            const template_assets = [];
            if (!!template_assets_ids) {
                const input_template_assets = await TemplateAsset.find({ where: { id: In(template_assets_ids) } });
                template_assets.push(...input_template_assets);
            }
            const product_assets = SectionUtils.update_asset(upsert_product_input.assets, assets, template_assets);
            product.assets = ProductAsset.create(product_assets);
            await product.save();
        }

        if (!!upsert_product_input.providers?.length) {
            await DatabaseUtils.transaction(context.db_data_source, async () => {
                const product_providers_to_upsert: ProductProvider[] = [];
                Object.assign(product_providers_to_upsert, upsert_product_input.providers);
                for (const [index, product_provider] of product_providers_to_upsert.entries()) {
                    product_provider.product = product;
                    product_provider.index = index;
                }
                await ProductProvider.createQueryBuilder().delete().where(`"productId" = ${product.id}`).execute();
                await ProductProvider.save(product_providers_to_upsert);
            });
        }

        return await context.loader.loadEntity(Product, "product").where(`product.id = ${product.id}`).info(info).loadOne();
    }

    @Authorized<Roles>([Roles.BASIC, Roles.TRUSTED, Roles.ADMIN, Roles.UNTRUSTED])
    @Mutation(() => Boolean, { name: "deleteProducts" })
    async delete(
        @Ctx() context: Context,
        @Info() info: GraphQLResolveInfo,
        @Arg("ids", () => [Int], { validate: true }) ids: number[]
    ) {
        await Product
            .createQueryBuilder()
            .delete()
            .where(`id IN (${ids})`)
            .execute();
        return true;
    }

    @Authorized<Roles>([Roles.BASIC, Roles.TRUSTED, Roles.ADMIN, Roles.UNTRUSTED])
    @Mutation(() => [ProductProvider], { name: "multipleProductsEdit" })
    async multipleProductsEdit(
        @Ctx() context: Context,
        @Info() info: GraphQLResolveInfo,
        @Arg("websiteId", () => Int!, { validate: true }) website_id: number,
        @Arg("multipleProductsEditInput", () => [MultipleProductsEditInput], { validate: true }) multiple_products_edit_input: MultipleProductsEditInput[]
    ): Promise<ProductProvider[]> {
        const products_ids: number[] = [];

        const products_providers: ProductProvider[] = [];
        for (const input of multiple_products_edit_input) {
            const source = {
                product: { id: input.product },
                provider: { id: input.provider },
                affiliate: { id: input.affiliate },
                index: input.newPosition
            };
            const product_provider = Object.assign(new ProductProvider(), source);
            products_ids.push(input.product);
            products_providers.push(product_provider);
        }


        await DatabaseUtils.transaction(context.db_data_source, async () => {
            await ProductProvider.createQueryBuilder().delete().where(`"productId" IN (${products_ids})`).execute();
            await ProductProvider.save(products_providers);
        });

        return await context.loader.loadEntity(ProductProvider, "product_provider").where(`product_provider."productId" IN (${products_ids})`).info(info).loadMany();
    }

    @Query(() => String, { name: "multipleProductsEditFileTemplate" })
    async multipleProductsEditFileTemplate(
        @Ctx() context: any,
        @Info() info: GraphQLResolveInfo,
        @Arg("websiteId", () => Int, { nullable: false, validate: true }) website_id: number,
        @Arg("activeProviders", () => Boolean, { nullable: false, validate: true }) active_providers: boolean,
        @Arg("productsIds", () => [Int!]!, { nullable: false, validate: true }) products_ids: number[]
    ): Promise<String> {
        const { domain, rows } = await ProductRankingFileUtils.get_csv_rows(website_id, active_providers, products_ids);
        return await ProductRankingFileUtils.upload_csv(rows, domain);
    }

    @Mutation(() => Boolean, { name: "multipleProductsFileEdit" })
    async multipleProductsFileEdit(
        @Ctx() context: any,
        @Info() info: GraphQLResolveInfo,
        @Arg("websiteId", () => Int!) websiteId: number,
        @Arg("csvFile", () => GraphQLUpload!) file: FileUpload
    ): Promise<boolean> {
        if (file.mimetype != "text/csv") {
            throw new Error(`Invalid file type ${file.mimetype}. Use .csv files only`);
        }
        const website = await Website.findOne({ where: { id: websiteId }, relations: ["products"] });
        if (!website) {
            throw new Error("Website Not Exists");
        }

        const outbounds: { id: number, name: string }[] = await Affiliate.createQueryBuilder("affiliates")
            .leftJoin("affiliates.provider", "providers")
            .where(`providers."websiteId" = ${website.id}`)
            .select("affiliates.name", "name")
            .addSelect("affiliates.id", "id")
            .getRawMany();

        const update_product_providers_position_rows: Array<ProductProvider> = [];
        const products_ids: number[] = [];

        const products_map = _.keyBy(website.products, "name");
        const outbounds_map = _.keyBy(outbounds, "name");

        const stream = file.createReadStream();
        const parseCsv = new Promise((resolve, reject) => {
            parseStream(stream, { headers: true })
                .on("error", (error) => reject(error))
                .on("data", async (row) => {
                    const source = {
                        product: { id: products_map[row.product].id },
                        provider: { id: row.providerId },
                        affiliate: { id: outbounds_map[row.outbound].id },
                        index: row.newPosition
                    };
                    products_ids.push(products_map[row.product].id);
                    update_product_providers_position_rows.push(Object.assign(new ProductProvider(), source));
                })
                .on("end", (_: any) => resolve(true));
        });

        await parseCsv;

        await DatabaseUtils.transaction(context.db_data_source, async () => {
            await ProductProvider.createQueryBuilder().delete().where(`"productId" IN (${products_ids})`).execute();
            await ProductProvider.save(update_product_providers_position_rows);
        });

        return true;
    }
}

File: /src/resolvers/AdServingCompanyResolver.ts 
import { AdServingCompany, Roles } from "@moonshot-marketing/creator-entities";
import { GraphQLResolveInfo } from "graphql";
import { Arg, Authorized, Ctx, Info, Int, Mutation, Query, Resolver } from "type-graphql";
import { AdServingCompanyInput } from "../inputs/AdServingCompanyInput";

@Resolver(() => AdServingCompany)
export class AdServingCompanyResolver {
    @Authorized<Roles>([Roles.BASIC, Roles.TRUSTED, Roles.ADMIN, Roles.UNTRUSTED])
    @Query(() => [AdServingCompany], { name: "adServingCompanies" })
    async read(@Ctx() context: any, @Info() info: GraphQLResolveInfo, @Arg("ids", () => [Int], { nullable: true }) ids?: number[]): Promise<AdServingCompany[]> {
        const whereExpressions: string[] = [];
        if (!!ids && ids.length) {
            whereExpressions.push(`adServingCompany.id IN (${ids})`);
        }
        const where = whereExpressions.join(" AND ");
        return await context.loader.loadEntity(AdServingCompany, "adServingCompany").where(where).info(info).loadMany();
    }

    @Authorized<Roles>([Roles.BASIC, Roles.TRUSTED, Roles.ADMIN])
    @Mutation(() => Boolean, { name: "deleteAdServingCompany" })
    async delete(@Arg("id", () => Int!) id: number): Promise<boolean> {
        const company = await AdServingCompany.findOne({
            where: { id },
            relations: ["websites"],
        });

        if (!company) {
            throw new Error("Ad serving company not found");
        }

        if (company.websites && company.websites.length > 0) {
            throw new Error(
                `Please disconnect the ad serving company from all websites before deleting it, currently connected websites are: ${company.websites
                    .map((website) => website.name)
                    .join(", ")}`,
            );
        }

        await AdServingCompany.delete(company.id);
        return true;
    }

    @Authorized<Roles>([Roles.BASIC, Roles.TRUSTED, Roles.ADMIN])
    @Mutation(() => [AdServingCompany], { name: "upsertAdServingCompany" })
    async upsert(@Arg("data", () => [AdServingCompanyInput], { validate: true }) companyInput: AdServingCompanyInput[]): Promise<AdServingCompany[]> {
        const companiesToSave = companyInput.map((el) => {
            const company = new AdServingCompany();
            Object.assign(company, el);
            return company;
        });
        return await AdServingCompany.save(companiesToSave);
    }
}

File: /src/resolvers/redirectsResolver.ts 
import { S3FileHostingHelper } from "@moonshot-marketing/creator-cloud";
import { Redirect, Roles, Website } from "@moonshot-marketing/creator-entities";
import { GraphQLResolveInfo } from "graphql";
import { Arg, Authorized, Ctx, Info, Int, Mutation, Query, Resolver } from "type-graphql";
import { In } from "typeorm";
import { CreateRedirectInput } from "../inputs/CreateRedirectInput";

@Resolver(() => Redirect)
export class RedirectsResolver {
    private readonly s3FileHostingHelper: S3FileHostingHelper;

    constructor() {
        this.s3FileHostingHelper = new S3FileHostingHelper();
    }

    @Authorized<Roles>([Roles.BASIC, Roles.TRUSTED, Roles.ADMIN, Roles.UNTRUSTED])
    @Query(() => [Redirect], { name: "redirect" })
    async read(@Ctx() context: any, @Info() info: GraphQLResolveInfo, @Arg("ids", () => [Int], { nullable: true }) ids?: [number]): Promise<Redirect[] | Redirect> {
        const whereExpressions: string[] = [];
        if (!!ids && ids.length) {
            whereExpressions.push(`redirect.id IN (${ids})`);
        }
        const where = whereExpressions.join(" AND ");
        return await context.loader.loadEntity(Redirect, "redirect").where(where).info(info).loadMany();
    }

    @Authorized<Roles>([Roles.BASIC, Roles.TRUSTED, Roles.ADMIN, Roles.UNTRUSTED])
    @Mutation(() => Boolean, { name: "deleteRedirect" })
    async delete(@Arg("ids", () => [Int]!) ids: number[]): Promise<boolean> {
        const dbRecordsToDelete = await Redirect.find({ where: { id: In(ids) }, relations: ["website"] });
        const dbRecordsToDeleteIds = dbRecordsToDelete.map((x) => x.id);
        if (dbRecordsToDeleteIds?.length === 0 || dbRecordsToDeleteIds?.length !== ids.length) {
            throw new Error("some redirects were not found");
        }
        await Redirect.delete(dbRecordsToDeleteIds);
        return true;
    }

    @Authorized<Roles>([Roles.BASIC, Roles.TRUSTED, Roles.ADMIN, Roles.UNTRUSTED])
    @Mutation(() => [Redirect], { name: "createRedirect" })
    async create(
        @Ctx() context: any,
        @Info() info: GraphQLResolveInfo,
        @Arg("data", () => CreateRedirectInput, { validate: true }) input: CreateRedirectInput,
    ): Promise<Redirect | Redirect[]> {
        const website: Website = await Website.findOne({ where: { id: input.website }, relations: ["redirects"] });
        if (!website) {
            throw new Error("Website not found");
        }

        // remove beginning slash(/) from incoming sources
        input.redirectInputArray.map(function (el) {
            el.source = el.source.startsWith("/") ? el.source.substr(1) : el.source;
            return el;
        });

        // validate non duplicate redirect (this source is not already set)
        const sourcesOnRunningRedirects = website.redirects.map((x) => x.source);
        const sourcesWaitingToSet = input.redirectInputArray.map((x) => x.source);
        const alreadyWasSetRedirects = sourcesWaitingToSet.filter((x) => sourcesOnRunningRedirects.includes(x));
        if (!!alreadyWasSetRedirects && !!alreadyWasSetRedirects.length) {
            throw new Error(`some redirects already was set ${alreadyWasSetRedirects}`);
        }

        const redirectsToSave = input.redirectInputArray.map((redirectData) => {
            const redirect = new Redirect();
            Object.assign(redirect, redirectData);
            redirect.website = website;
            return redirect;
        });

        return await Redirect.save(redirectsToSave);
    }
}

File: /src/resolvers/RssResolver.ts 
import { Arg, Ctx, Info, Int, Mutation, Query, Resolver } from "type-graphql";
import { RssEvent, Website } from "@moonshot-marketing/creator-entities";
import { GraphQLResolveInfo } from "graphql";
import { RssEventInput } from "../inputs/RssEventInput";
import * as _ from "lodash";
import { DataSource } from "typeorm";
import { CloudFrontHelper } from "@moonshot-marketing/creator-cloud";

@Resolver(() => RssEvent)
export class RssResolver {

    private readonly cloudFrontHelper: CloudFrontHelper = new CloudFrontHelper();

    @Query(() => [RssEvent], { name: "rssEvents" })
    async rssEvents(
        @Ctx() context: any,
        @Info() info: GraphQLResolveInfo,
        @Arg("websiteId", () => Int!, { validate: true, nullable: false }) website_id: number,
    ): Promise<Array<RssEvent>> {
        return await context.loader.loadEntity(RssEvent, "rss_events").where(`rss_events.website_id = ${website_id}`).info(info).loadMany();
    }

    @Mutation(() => [RssEvent], { name: "updateRssEvents" })
    async updateRssEvents(
        @Ctx() context: any,
        @Info() info: GraphQLResolveInfo,
        @Arg("websiteId", () => Int!, { validate: true, nullable: false }) website_id: number,
        @Arg("rssEvents", () => [RssEventInput!]!, { validate: true }) rss_events: RssEventInput[],
    ): Promise<Array<RssEvent>> {
        const website = await Website.findOneByOrFail({ id: website_id });
        const db_data_source: DataSource = context.db_data_source;
        const queryRunner = db_data_source.createQueryRunner();
        await queryRunner.startTransaction();
        try {
            const website_rss_events = await RssEvent.findBy({ website: { id: website_id } });
            const events: RssEvent[] = _.map(Object.assign([], rss_events), event => ({ ...event, website: { id: website_id } }));
            for (const event of events) {
                event.date.setHours(event.date.getHours() - 2);
            }
            await RssEvent.save(events);
            await RssEvent.softRemove(website_rss_events);
            await queryRunner.commitTransaction();
        } catch (err) {
            await queryRunner.rollbackTransaction();
        } finally {
            await queryRunner.release();
        }

        setTimeout(() => {
            try {
                this.cloudFrontHelper.invalidateFiles(website.distributionId, [`/realtime/${website_id}/rss`]);
            } catch (e) {
                console.error(`failed to invalidate path "/realtime/${website_id}/rss", err = ${JSON.stringify(e)}`);
            }
        }, 60000);

        return await context.loader.loadEntity(RssEvent, "rss_events").where(`rss_events.website_id = ${website_id}`).info(info).loadMany();
    }

}
File: /src/argsTypes/GetWebsitePageArgs.ts 
import { PageStatus, PageState, PageType } from "@moonshot-marketing/creator-entities";
import { ArgsType, Field, Int } from "type-graphql";

@ArgsType()
export class GetWebsitePageArgs {

    @Field(() => String, { nullable: true })
    path: string;

    @Field(() => Int, { nullable: false })
    websiteId: number;

    @Field(() => PageState, { nullable: true })
    state: PageState;

    @Field(() => PageStatus, { nullable: true })
    status: PageStatus;

    @Field(() => Boolean, { nullable: true })
    ignoreTestPages?: boolean;

    @Field(() => Boolean, { nullable: true })
    ignoreArchivePages?: boolean;

    @Field(() => Int, { nullable: true })
    numOfChunks?: number;

    @Field(() => Int, { nullable: true })
    chunkNumber?: number;

    @Field(() => Int, { nullable: true })
    verticalId?: number;

    @Field(() => [PageType], { nullable: true })
    pageTypes?: PageType[];
}


File: /src/argsTypes/OrderArgs.ts 
import { ArgsType, Field } from "type-graphql";
import { OrderActions } from "@moonshot-marketing/creator-entities";

@ArgsType()
export class OrderArgs {

  @Field(() => String, { nullable: true })
  field?: string;

  @Field(() => OrderActions, { nullable: true })
  action?: OrderActions;

}



File: /src/argsTypes/GetWebsiteArgs.ts 
import { PageType, DNSVerificationStatus, PageState, PageStatus } from "@moonshot-marketing/creator-entities";
import { ArgsType, Field, Int } from "type-graphql";

@ArgsType()
export class GetWebsiteArgs {

    @Field(() => [Int], { nullable: true })
    ids: number[];

    @Field(() => [String], { nullable: true })
    domains: string[];

    @Field(() => DNSVerificationStatus, { nullable: true })
    dnsVerificationStatus: string;

    @Field(() => Boolean, { nullable: true })
    ignoreTestPages?: boolean;

    @Field(() => PageState, { nullable: true })
    pageState?: PageState;

    @Field(() => PageStatus, { nullable: true })
    pageStatus?: PageStatus;

    @Field(() => Boolean, { nullable: true })
    ignoreArchivePages?: boolean;

    @Field(() => PageType, { nullable: true })
    pageType?: PageType;

    @Field(() => String, { nullable: true })
    componentName?: string;

    @Field(() => Boolean, { nullable: true, defaultValue: false })
    isExternal?: boolean;

    @Field(() => Boolean, { nullable: true, defaultValue: false })
    uploadSales?: boolean;

    @Field(() => [String], { nullable: true, defaultValue: [] })
    salesforceIds?: string[];
}


File: /src/argsTypes/PaginationArgs.ts 
import { Min } from "class-validator";
import { ArgsType, Field, Int } from "type-graphql";

@ArgsType()
export class PaginationArgs {

  @Field(() => Int, { nullable: true })
  @Min(0)
  offset?: number;

  @Field(() => Int, { nullable: true })
  @Min(1)
  take?: number;

}

File: /src/validators/FilterDataValidator.ts 
import {
    registerDecorator,
    ValidationOptions,
    ValidationArguments,
    ValidatorConstraint,
    ValidatorConstraintInterface
} from "class-validator";
import { FilterDataInput } from "../inputs/WebsiteFilter/FilterDataInput";
import * as _ from "lodash";

@ValidatorConstraint({ async: false })
export class FilterDataValueValidator implements ValidatorConstraintInterface {

    validate(value: FilterDataInput, args: ValidationArguments): boolean {
        const keys_len = _.keys(_.omitBy(value, _.isNil)).length;
        return !!keys_len;
    }

    defaultMessage(args: ValidationArguments) {
        return "Must include one key at least";
    }
}

export function MustHaveOne(validationOptions?: ValidationOptions) {
    return (object: Object, propertyName: string) => {
        registerDecorator({
            name: "MustHaveOne",
            target: object.constructor,
            propertyName: propertyName,
            constraints: [],
            options: validationOptions,
            validator: FilterDataValueValidator,
        });
    };
}

File: /src/server.ts 
if (process.env.NODE_ENV !== "development") require("newrelic");

import * as Models from "@moonshot-marketing/creator-entities/";
import { CreatorServerV2 } from "@moonshot-marketing/creator-server";
import "reflect-metadata";
import { AdServingCompanyResolver } from "./resolvers/AdServingCompanyResolver";
import { MediaGalleryResolver } from "./resolvers/mediaGalleryResolver";
import { ProductResolver } from "./resolvers/ProductResolver";
import { PublishSchedulingResolver } from "./resolvers/publishSchedulingResolver";
import { RedirectsResolver } from "./resolvers/redirectsResolver";
import { RssResolver } from "./resolvers/RssResolver";
import { SitemapResolver } from "./resolvers/sitemapResolver";
import { SourcesResolver } from "./resolvers/SourcesResolver";
import { WebsiteResolver } from "./resolvers/WebsiteResolver";
const server = new CreatorServerV2(
    [
        ProductResolver,
        WebsiteResolver,
        SourcesResolver,
        RedirectsResolver,
        MediaGalleryResolver,
        SitemapResolver,
        PublishSchedulingResolver,
        RssResolver,
        AdServingCompanyResolver,
    ],
    Models,
);
server.run().catch(console.error);

File: /src/interfaces/google/protobuf/struct.ts 
/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";

export const protobufPackage = "google.protobuf";

/**
 * `NullValue` is a singleton enumeration to represent the null value for the
 * `Value` type union.
 *
 *  The JSON representation for `NullValue` is JSON `null`.
 */
export enum NullValue {
  /** NULL_VALUE - Null value. */
  NULL_VALUE = 0,
  UNRECOGNIZED = -1,
}

/**
 * `Struct` represents a structured data value, consisting of fields
 * which map to dynamically typed values. In some languages, `Struct`
 * might be supported by a native representation. For example, in
 * scripting languages like JS a struct is represented as an
 * object. The details of that representation are described together
 * with the proto support for the language.
 *
 * The JSON representation for `Struct` is JSON object.
 */
export interface Struct {
  /** Unordered map of dynamically typed values. */
  fields: { [key: string]: any | undefined };
}

export interface Struct_FieldsEntry {
  key: string;
  value: any | undefined;
}

/**
 * `Value` represents a dynamically typed value which can be either
 * null, a number, a string, a boolean, a recursive struct value, or a
 * list of values. A producer of value is expected to set one of that
 * variants, absence of any variant indicates an error.
 *
 * The JSON representation for `Value` is JSON value.
 */
export interface Value {
  /** Represents a null value. */
  nullValue: NullValue | undefined;
  /** Represents a double value. */
  numberValue: number | undefined;
  /** Represents a string value. */
  stringValue: string | undefined;
  /** Represents a boolean value. */
  boolValue: boolean | undefined;
  /** Represents a structured value. */
  structValue: { [key: string]: any } | undefined;
  /** Represents a repeated `Value`. */
  listValue: Array<any> | undefined;
}

/**
 * `ListValue` is a wrapper around a repeated field of values.
 *
 * The JSON representation for `ListValue` is JSON array.
 */
export interface ListValue {
  /** Repeated field of dynamically typed values. */
  values: any[];
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

File: /src/interfaces/ProductRankingRow.ts 
export interface ProductRankingRow {
    product: string;
    outbound: string;
    providerId: number;
    providerName: string;
    currentPosition: number;
    newPosition: number;
}

File: /src/interfaces/ClonePageCSVInputLine.ts 
export interface ClonePageCSVInputLine {
    sourceTitle: string;
    sourcePath: string;
    destTitle: string;
    destPath: string;
}

File: /src/interfaces/click.ts 
/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";

export const protobufPackage = "";

export interface Click {
  website: string;
  finalUrl: string;
  referrerFinalUrl: string;
  userAgent: string;
  trackerVersion: string;
  siteParameters: { [key: string]: any } | undefined;
  isCreator: boolean;
  extra: { [key: string]: any } | undefined;
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

File: /src/inputs/UpdateSitemapInput.ts 
import { Field, InputType, Int } from "type-graphql";
import {  Matches } from "class-validator";

@InputType()
export class UpdateSitemapInput {

    @Field(() => Int, { nullable: false } )
    id: number;

    @Field(() => String, { nullable: false } )
    @Matches(/\/[a-zA-Z0-9_-]*.html/, {message: "path Not Valid"})
    path: string;

    @Field(() => Int, { nullable: true } )
    parentId: number | null;

}


File: /src/inputs/updateMediaGalleryAssetInput.ts 
import { Field, InputType } from "type-graphql";

@InputType()
export class UpdateMediaGalleryAssetInput {
    @Field(() => String!)
    path: string;

    @Field(() => String, { nullable: true })
    altText?: string;

    @Field(() => String, { nullable: true })
    filename?: string;
}

File: /src/inputs/PublishHistoryInput.ts 
import { Field, InputType, Int } from "type-graphql";
import { PublishStatus } from "@moonshot-marketing/creator-entities";

@InputType()
export class PublishHistoryInput {

    @Field(() => String, { nullable: false } )
    jobId: number;

    @Field(() => Int, { nullable: false })
    websiteId: number;

    @Field(() => PublishStatus, { nullable: true } )
    status: string;

    @Field(() => Date, { nullable: true })
    startedAt: Date;

    @Field(() => Date, { nullable: true })
    finishedAt: Date;
}


File: /src/inputs/mediaGalleryAssetInput.ts 
import { Field, InputType } from "type-graphql";
import { FileUpload, GraphQLUpload } from "graphql-upload";

@InputType()
export class MediaGalleryAssetInput {

    @Field(() => String!)
    filename: string;

    @Field(() => GraphQLUpload!)
    image: FileUpload;

    @Field(() => String!)
    altText?: string;
}

File: /src/inputs/MultipleProductsEditInput.ts 
import { Field, InputType, Int } from "type-graphql";

@InputType()
export class MultipleProductsEditInput {

    @Field(() => Int)
    product: number;

    @Field(() => Int)
    provider: number;

    @Field(() => Int)
    affiliate: number;

    @Field(() => Int)
    currentPosition: number;

    @Field(() => Int)
    newPosition: number;
}
File: /src/inputs/CreateWebsiteInput.ts 
import { CompanyTypes, WebsiteStrategy } from "@moonshot-marketing/creator-entities";
import { IsEnum } from "class-validator";
import { Field, InputType, Int } from "type-graphql";

@InputType()
export class CreateWebsiteInput {
    @Field({ nullable: false })
    name: string;

    @Field({ nullable: false })
    template: number;

    @Field(() => CompanyTypes, { nullable: true, defaultValue: CompanyTypes.MOONSHOT })
    companyType: CompanyTypes;

    @IsEnum(WebsiteStrategy)
    @Field(() => WebsiteStrategy, { nullable: true })
    strategy?: WebsiteStrategy;

    @Field(() => Int, { nullable: true })
    adServingCompany?: number;
}

File: /src/inputs/InsertWebsiteInput.ts 
import { CompanyTypes, User, WebsiteStatus, WebsiteStrategy, WebsitesTypes } from "@moonshot-marketing/creator-entities";
import { IsEnum, IsUrl } from "class-validator";
import { Field, InputType, Int } from "type-graphql";
import { UserInput } from "./UserInput";

@InputType()
export class InsertWebsiteInput {
    @Field({ nullable: true })
    isExternal: boolean;

    @Field({ nullable: false })
    name: string;

    @Field({ nullable: true })
    costCeter: string;

    @Field({ nullable: true })
    salesforceId: string;

    @Field({ nullable: false })
    @IsUrl({ require_protocol: false, require_host: true, allow_underscores: true })
    domain: string;

    @Field({ nullable: true })
    isEnabled: boolean;

    @Field({ nullable: true })
    distributionId: string;

    @Field(() => [String], { nullable: true })
    nameServers: string[];

    @Field(() => String, { nullable: true })
    hostedZoneId: string;

    @Field(() => Int, { nullable: false })
    template: number;

    @Field({ nullable: true })
    publishedAt: Date;

    @Field(() => Int, { nullable: true })
    numOfProviderLists: number;

    @Field({ nullable: true })
    isAfSite: boolean;

    @IsEnum(WebsiteStrategy)
    @Field(() => WebsiteStrategy, { nullable: true })
    websiteStrategy?: WebsiteStrategy;

    @Field(() => UserInput, { nullable: true })
    owner: User;

    @Field(() => [UserInput], { nullable: true, deprecationReason: "use usersPermitted" })
    websitesUsersPermitted: User[];

    @IsEnum(WebsiteStatus)
    @Field(() => WebsiteStatus, { nullable: true })
    status: WebsiteStatus;

    @IsEnum(CompanyTypes)
    @Field(() => CompanyTypes, { nullable: true, defaultValue: CompanyTypes.MOONSHOT })
    companyType: CompanyTypes;

    @IsEnum(WebsitesTypes)
    @Field(() => WebsitesTypes, { nullable: true })
    type: WebsitesTypes;

    @Field(() => [UserInput], { nullable: true })
    usersPermitted: User[];

    @Field({ nullable: false })
    bucketName: string;

    @Field(() => Int, { nullable: true })
    adServingCompany?: number;
}

File: /src/inputs/createPublishSchedulingInput.ts 
import { Field, InputType, Int } from "type-graphql";

@InputType()
export class CreatePublishSchedulingInput {

    @Field(() => Int, { nullable: false })
    websiteId: number;

    @Field(() => Date, { nullable: false })
    publishAt: Date;

    @Field(() => String, { nullable: false })
    templateName: String;

    @Field(() => String, { nullable: false })
    templateVersion: String;

    @Field(() => String, { nullable: false })
    token: String;
}
File: /src/inputs/AdServingCompanyInput.ts 
import { Field, InputType, Int } from "type-graphql";

@InputType()
export class AdServingCompanyInput {
    @Field(() => Int, { nullable: true })
    id?: number;

    @Field()
    name: string;

    @Field(() => String, { nullable: true })
    googleMcc?: string;

    @Field(() => String, { nullable: true })
    bingMcc?: string;
}

File: /src/inputs/UpdateSourceInput.ts 
import { Field, InputType, Int } from "type-graphql";
import { SourceInput } from "./SourceInput";

@InputType()
export class UpdateSourceInput extends SourceInput {
    @Field( () => Int)
    id: number;
}
File: /src/inputs/RssEventTeamInput.ts 
import { Field, InputType } from "type-graphql";
import { IsUrl } from "class-validator";

@InputType()
export class RssEventTeamInput {

    @Field(() => String)
    name: string;

    @Field(() => String)
    @IsUrl()
    image: string;
}
File: /src/inputs/CreateRedirectInput.ts 
import { Field, InputType, Int } from "type-graphql";
import { RedirectType } from "@moonshot-marketing/creator-entities";

@InputType()
export class CreateRedirectInput {

    @Field(() => Int)
    website: number;

    @Field(() => [RedirectInputFields])
    redirectInputArray: RedirectInputFields[];
}

@InputType()
export class RedirectInputFields {

    @Field(() => RedirectType)
    type: RedirectType;

    @Field()
    source: string;

    @Field()
    destination: string;
}


File: /src/inputs/WebsiteFilter/SelectionOptionInput.ts 
import { Field, InputType } from "type-graphql";
import { IconPropsInput } from "./IconPropsInput";

@InputType()
export class SelectionOptionInput {

    @Field(() => String)
    value: string;

    @Field()
    label: string;

    @Field(() => IconPropsInput, { nullable: true })
    icon?: IconPropsInput;
}

File: /src/inputs/WebsiteFilter/WebsiteFilterInput.ts 
import { IconPropsInput } from "./IconPropsInput";
import { FilterDataInput } from "./FilterDataInput";
import { Field, InputType, Int } from "type-graphql";
import { WebsiteFilterOptionType, IconProps } from "@moonshot-marketing/creator-entities";
import { MustHaveOne } from "../../validators/FilterDataValidator";

@InputType()
export class WebsiteFilterInput {

    @Field(() => Int, { nullable: true })
    id: number;

    @Field(() => String, { nullable: true })
    name: string;

    @Field(() => String, { nullable: true })
    label: string;

    @Field(() => String, { nullable: true })
    title?: string;

    @Field(() => String, { nullable: true })
    placeholder?: string;

    @Field(() => WebsiteFilterOptionType)
    type: WebsiteFilterOptionType;

    @Field(() => Boolean)
    isCustom: boolean;

    @Field(() => IconPropsInput, { nullable: true })
    icon: IconProps;

    @Field(() => FilterDataInput)
    @MustHaveOne()
    data: FilterDataInput;

    @Field(() => String)
    prefixText: string;

}

File: /src/inputs/WebsiteFilter/RangeOptionInput.ts 
import { Field, InputType } from "type-graphql";

@InputType()
export class RangeOptionInput {
    @Field()
    min: number;

    @Field()
    max: number;
}

File: /src/inputs/WebsiteFilter/IconPropsInput.ts 
import { Field, InputType } from "type-graphql";

@InputType()
export class IconPropsInput {

    @Field()
    src: string;

    @Field()
    alt: string;
}

File: /src/inputs/WebsiteFilter/FilterDataInput.ts 
import { Field, InputType } from "type-graphql";
import { RangeOptionInput } from "./RangeOptionInput";
import { SelectionOptionInput } from "./SelectionOptionInput";

// one of them must have value
@InputType()
export class FilterDataInput {

    @Field(() => String, { nullable: true })
    textOption?: string;

    @Field(() => RangeOptionInput, { nullable: true })
    rangeOptions?: RangeOptionInput;

    @Field(() => [SelectionOptionInput], { nullable: true })
    selectOptions?: SelectionOptionInput[];

    @Field(() => Number, { nullable: true })
    number?: number;

}

File: /src/inputs/SourceInput.ts 
import { Currency, SourceType, TimeZone } from "@moonshot-marketing/creator-entities";
import { Field, InputType, Int } from "type-graphql";

@InputType()
export class SourceInput {

    @Field()
    enabled: boolean;

    @Field( () => SourceType )
    type: number;

    @Field()
    externalAccountId: string;

    @Field( () => TimeZone)
    timeZone: string;

    @Field( () => Currency)
    currency: string;

    @Field( () => Int)
    website: number;

    @Field(() => Boolean, { defaultValue: true })
    createConversion: boolean;
}

File: /src/inputs/UpsertWebsiteVerticalsInput.ts 
import { Field, InputType, Int } from "type-graphql";

@InputType()
export class UpsertWebsiteVerticalsInput {

    @Field({ nullable: true })
    id: number;

    @Field({ nullable: false })
    name: string;

    @Field(() => [Int], { nullable: true, defaultValue: [] })
    providers: number[];
}


File: /src/inputs/UpdateWebsiteVisitorsCounterInput.ts 
import { VisitorsCounterTTL } from "@moonshot-marketing/creator-entities";
import { Field, InputType, Int } from "type-graphql";

@InputType()
export class UpdateWebsiteVisitorsCounterInput {

    @Field(() => Int)
    id: number;

    @Field(() => Int)
    initialCounterValue: number;

    @Field(() => VisitorsCounterTTL)
    renewPeriod: VisitorsCounterTTL;

}

File: /src/inputs/UpsertProductsInput.ts 
import { Field, InputType, Int } from "type-graphql";
import { UpsertProductProvidersInput } from "./UpsertProductProvidersInput";
import { UpdateAssetInput } from "@moonshot-marketing/creator-entities";

@InputType()
export class UpsertProductsInput {

    @Field(() => Int, { nullable: true } )
    id: number;

    @Field(() => String, { nullable: false } )
    name: string;

    @Field( () => Int, { nullable: true } )
    website: number;

    @Field(() => [UpdateAssetInput], { nullable: true })
    assets: UpdateAssetInput[];

    @Field(() => [UpsertProductProvidersInput], { nullable: true, defaultValue: [] })
    providers: UpsertProductProvidersInput[];
}

File: /src/inputs/UpdateWebsiteMetaTagInput.ts 
import { Field, InputType } from "type-graphql";

@InputType()
export class UpdateWebsiteMetaTagInput {

    @Field(() => String)
    key: string;

    @Field(() => String)
    value: string;

}

File: /src/inputs/UserInput.ts 
import { Field, InputType, Int } from "type-graphql";

@InputType()
export class UserInput {

    @Field(() => Int)
    id: number;

}


File: /src/inputs/RssEventInput.ts 
import { Field, InputType } from "type-graphql";
import { RssEventFormat } from "@moonshot-marketing/creator-entities";
import { RssEventTeamInput } from "./RssEventTeamInput";

@InputType()
export class RssEventInput {

    @Field(() => RssEventFormat, { nullable: false } )
    format: RssEventFormat;

    @Field(() => Date, { nullable: false } )
    date: Date;

    @Field(() => Boolean, { nullable: false } )
    dateBold: boolean;

    @Field(() => Boolean, { nullable: false } )
    teamsBold: boolean;

    @Field(() => RssEventTeamInput, { nullable: false } )
    team1: RssEventTeamInput;

    @Field(() => RssEventTeamInput, { nullable: false } )
    team2: RssEventTeamInput;

}
File: /src/inputs/UpdateWebsiteInput.ts 
import { ClarityStatus, DNSVerificationStatus, ObChecksRegions, User, WebsiteStatus, WebsiteStrategy } from "@moonshot-marketing/creator-entities";
import { IsNotEmpty, IsOptional, IsUrl, ValidateIf } from "class-validator";
import { Field, Float, InputType, Int } from "type-graphql";
import { UpdateWebsiteMetaTagInput } from "./UpdateWebsiteMetaTagInput";
import { UpdateWebsiteVisitorsCounterInput } from "./UpdateWebsiteVisitorsCounterInput";
import { UserInput } from "./UserInput";

@InputType()
export class UpdateWebsiteInput {
    @Field(() => Int, { nullable: false })
    id: number;

    @Field(() => WebsiteStatus, { nullable: true })
    status: string;

    @Field(() => UserInput, { nullable: true })
    owner: User;

    @Field(() => [UserInput], { nullable: true, deprecationReason: "use usersPermitted" })
    websitesUsersPermitted: User[];

    @Field(() => String, { nullable: true })
    title: string;

    @Field(() => Boolean, { nullable: true })
    clearParamsFromUrl: boolean;

    @Field(() => Boolean, { nullable: true })
    isPublishRunning: boolean;

    @Field(() => [UpdateWebsiteMetaTagInput], { nullable: true })
    metaTags: UpdateWebsiteMetaTagInput[];

    @Field(() => String, { nullable: true })
    name: string;

    @Field({ nullable: true })
    costCeter: string;

    @Field(() => [String], { nullable: true })
    dnsRecords: string[];

    @Field(() => [String], { nullable: true })
    nameServers: string[];

    @Field(() => String, { nullable: true })
    hostedZoneId: string;

    @Field(() => String, { nullable: true })
    distributionId: string;

    @Field(() => DNSVerificationStatus, { nullable: true })
    dnsVerificationStatus: string;

    @Field(() => Int, { nullable: true })
    template: number;

    @Field(() => Int, { nullable: true })
    numOfProviderLists: number;

    @Field(() => Date, { nullable: true })
    publishedAt: Date;

    @Field(() => [UserInput], { nullable: true })
    usersPermitted: User[];

    @Field(() => String, { nullable: true })
    gtmId: string | null;

    @Field(() => String, { nullable: true })
    clarityId: string;

    @Field(() => String, { nullable: true })
    oneSignalAppId: string;

    @Field(() => String, { nullable: true })
    oneSignalApiKey: string;

    @Field(() => Boolean, { nullable: true })
    applySpeedCurve: boolean;

    @Field(() => Boolean, { nullable: true })
    seoRobotsFollow: boolean;

    @Field(() => Boolean, { nullable: true })
    seoRobotsIndex: boolean;

    @Field(() => Boolean, { nullable: true })
    isMonitored: boolean;

    @Field(() => String, { nullable: true })
    cookieScriptID: string;

    @Field(() => String, { nullable: true })
    cmsVersion: string;

    @Field(() => String, { nullable: true })
    slackChannel: string;

    @Field(() => UpdateWebsiteVisitorsCounterInput, { nullable: true })
    websiteVisitorsCounter: UpdateWebsiteVisitorsCounterInput;

    @Field(() => String, { nullable: true })
    googleAnalyticsId: string;

    @Field(() => String, { nullable: true })
    facebookPixel: string;

    @Field(() => String, { nullable: true })
    twitterPixel: string;

    @Field(() => String, { nullable: true })
    taboolaPixel: string;

    @Field(() => String, { nullable: true })
    snapchatPixel: string;

    @Field(() => String, { nullable: true })
    tikTokPixel: string;

    @Field(() => String, { nullable: true })
    hotJar: string;

    @Field(() => WebsiteStrategy, { nullable: true })
    websiteStrategy: string;

    @Field(() => String, { nullable: true })
    salesforceId: string;

    @Field(() => String, { nullable: true })
    @IsOptional()
    @IsNotEmpty()
    @ValidateIf((obj) => obj.trustPilotDomain !== null && obj.trustPilotDomain !== "")
    @IsUrl(undefined, { message: "TurstPilot url should have a valid url format - e.g https://trustpilot.com " })
    trustPilotDomain: string;

    @Field(() => Int, { nullable: true })
    trustPilotVotes: number;

    @Field(() => Float, { nullable: true })
    trustPilotRating: number;

    @Field(() => Int, { nullable: true })
    faviconMediaGalleryAsset: number;

    @Field(() => Boolean, { nullable: true })
    realtimeRss: boolean;

    @Field(() => Int, { nullable: true })
    conversionValueThreshold: number;

    @Field(() => Int, { nullable: true })
    rootPageId: number;

    @Field(() => Int, { nullable: true })
    errorRootPageId: number;

    @Field(() => ClarityStatus, { nullable: true })
    clarityStatus: ClarityStatus;

    @Field(() => ObChecksRegions, { nullable: true })
    obChecksLocation: ObChecksRegions;

    @Field(() => Int, { nullable: true })
    adServingCompany: number;
}

File: /src/inputs/UpsertProductProvidersInput.ts 
import { Field, InputType, Int } from "type-graphql";

@InputType()
export class UpsertProductProvidersInput {

    @Field(() => Int, { nullable: true } )
    provider: number;

    @Field(() => Int, { nullable: true } )
    affiliate: number;

}


